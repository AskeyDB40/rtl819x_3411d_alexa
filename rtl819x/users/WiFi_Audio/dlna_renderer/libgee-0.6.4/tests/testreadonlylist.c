/* testreadonlylist.c generated by valac 0.15.0.90-e9553, the Vala compiler
 * generated from testreadonlylist.vala, do not modify */

/* testreadonlylist.vala
 *
 * Copyright (C) 2008  Jürg Billeter
 * Copyright (C) 2009  Didier Villevalois
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Tomaž Vajngerl <quikee@gmail.com>
 * 	Julien Peeters <contact@julienpeeters.fr>
 * 	Didier 'Ptitjes' Villevalois <ptitjes@free.fr>
 */

#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>


#define GEE_TYPE_TEST_CASE (gee_test_case_get_type ())
#define GEE_TEST_CASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_TEST_CASE, GeeTestCase))
#define GEE_TEST_CASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_TEST_CASE, GeeTestCaseClass))
#define GEE_IS_TEST_CASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_TEST_CASE))
#define GEE_IS_TEST_CASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_TEST_CASE))
#define GEE_TEST_CASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_TEST_CASE, GeeTestCaseClass))

typedef struct _GeeTestCase GeeTestCase;
typedef struct _GeeTestCaseClass GeeTestCaseClass;
typedef struct _GeeTestCasePrivate GeeTestCasePrivate;

#define TYPE_READ_ONLY_COLLECTION_TESTS (read_only_collection_tests_get_type ())
#define READ_ONLY_COLLECTION_TESTS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_READ_ONLY_COLLECTION_TESTS, ReadOnlyCollectionTests))
#define READ_ONLY_COLLECTION_TESTS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_READ_ONLY_COLLECTION_TESTS, ReadOnlyCollectionTestsClass))
#define IS_READ_ONLY_COLLECTION_TESTS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_READ_ONLY_COLLECTION_TESTS))
#define IS_READ_ONLY_COLLECTION_TESTS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_READ_ONLY_COLLECTION_TESTS))
#define READ_ONLY_COLLECTION_TESTS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_READ_ONLY_COLLECTION_TESTS, ReadOnlyCollectionTestsClass))

typedef struct _ReadOnlyCollectionTests ReadOnlyCollectionTests;
typedef struct _ReadOnlyCollectionTestsClass ReadOnlyCollectionTestsClass;
typedef struct _ReadOnlyCollectionTestsPrivate ReadOnlyCollectionTestsPrivate;

#define TYPE_READ_ONLY_LIST_TESTS (read_only_list_tests_get_type ())
#define READ_ONLY_LIST_TESTS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_READ_ONLY_LIST_TESTS, ReadOnlyListTests))
#define READ_ONLY_LIST_TESTS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_READ_ONLY_LIST_TESTS, ReadOnlyListTestsClass))
#define IS_READ_ONLY_LIST_TESTS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_READ_ONLY_LIST_TESTS))
#define IS_READ_ONLY_LIST_TESTS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_READ_ONLY_LIST_TESTS))
#define READ_ONLY_LIST_TESTS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_READ_ONLY_LIST_TESTS, ReadOnlyListTestsClass))

typedef struct _ReadOnlyListTests ReadOnlyListTests;
typedef struct _ReadOnlyListTestsClass ReadOnlyListTestsClass;
typedef struct _ReadOnlyListTestsPrivate ReadOnlyListTestsPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _GeeTestCase {
	GObject parent_instance;
	GeeTestCasePrivate * priv;
};

struct _GeeTestCaseClass {
	GObjectClass parent_class;
	void (*set_up) (GeeTestCase* self);
	void (*tear_down) (GeeTestCase* self);
};

struct _ReadOnlyCollectionTests {
	GeeTestCase parent_instance;
	ReadOnlyCollectionTestsPrivate * priv;
	GeeCollection* test_collection;
	GeeCollection* ro_collection;
};

struct _ReadOnlyCollectionTestsClass {
	GeeTestCaseClass parent_class;
	GeeCollection* (*get_ro_view) (ReadOnlyCollectionTests* self, GeeCollection* collection);
};

struct _ReadOnlyListTests {
	ReadOnlyCollectionTests parent_instance;
	ReadOnlyListTestsPrivate * priv;
};

struct _ReadOnlyListTestsClass {
	ReadOnlyCollectionTestsClass parent_class;
};

typedef void (*GeeTestCaseTestMethod) (void* user_data);

static gpointer read_only_list_tests_parent_class = NULL;

GType gee_test_case_get_type (void) G_GNUC_CONST;
GType read_only_collection_tests_get_type (void) G_GNUC_CONST;
GType read_only_list_tests_get_type (void) G_GNUC_CONST;
enum  {
	READ_ONLY_LIST_TESTS_DUMMY_PROPERTY
};
ReadOnlyListTests* read_only_list_tests_new (void);
ReadOnlyListTests* read_only_list_tests_construct (GType object_type);
ReadOnlyCollectionTests* read_only_collection_tests_new_with_name (const gchar* name);
ReadOnlyCollectionTests* read_only_collection_tests_construct_with_name (GType object_type, const gchar* name);
void gee_test_case_add_test (GeeTestCase* self, const gchar* name, GeeTestCaseTestMethod test, void* test_target);
void read_only_list_tests_test_immutable_iterator (ReadOnlyListTests* self);
static void _read_only_list_tests_test_immutable_iterator_gee_test_case_test_method (gpointer self);
void read_only_list_tests_test_immutable (ReadOnlyListTests* self);
static void _read_only_list_tests_test_immutable_gee_test_case_test_method (gpointer self);
void read_only_list_tests_test_accurate_view (ReadOnlyListTests* self);
static void _read_only_list_tests_test_accurate_view_gee_test_case_test_method (gpointer self);
static void read_only_list_tests_real_set_up (GeeTestCase* base);
GeeCollection* read_only_collection_tests_get_ro_view (ReadOnlyCollectionTests* self, GeeCollection* collection);
static void read_only_list_tests_real_tear_down (GeeTestCase* base);
static GeeCollection* read_only_list_tests_real_get_ro_view (ReadOnlyCollectionTests* base, GeeCollection* collection);


static void _read_only_list_tests_test_immutable_iterator_gee_test_case_test_method (gpointer self) {
	read_only_list_tests_test_immutable_iterator (self);
}


static void _read_only_list_tests_test_immutable_gee_test_case_test_method (gpointer self) {
	read_only_list_tests_test_immutable (self);
}


static void _read_only_list_tests_test_accurate_view_gee_test_case_test_method (gpointer self) {
	read_only_list_tests_test_accurate_view (self);
}


ReadOnlyListTests* read_only_list_tests_construct (GType object_type) {
	ReadOnlyListTests * self = NULL;
	self = (ReadOnlyListTests*) read_only_collection_tests_construct_with_name (object_type, "ReadOnlyList");
	gee_test_case_add_test ((GeeTestCase*) self, "[ReadOnlyList] immutable iterator", _read_only_list_tests_test_immutable_iterator_gee_test_case_test_method, self);
	gee_test_case_add_test ((GeeTestCase*) self, "[ReadOnlyList] immutable", _read_only_list_tests_test_immutable_gee_test_case_test_method, self);
	gee_test_case_add_test ((GeeTestCase*) self, "[ReadOnlyList] accurate view", _read_only_list_tests_test_accurate_view_gee_test_case_test_method, self);
	return self;
}


ReadOnlyListTests* read_only_list_tests_new (void) {
	return read_only_list_tests_construct (TYPE_READ_ONLY_LIST_TESTS);
}


static void read_only_list_tests_real_set_up (GeeTestCase* base) {
	ReadOnlyListTests * self;
	GeeArrayList* _tmp0_;
	GeeCollection* _tmp1_;
	GeeCollection* _tmp2_ = NULL;
	self = (ReadOnlyListTests*) base;
	_tmp0_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL);
	_g_object_unref0 (((ReadOnlyCollectionTests*) self)->test_collection);
	((ReadOnlyCollectionTests*) self)->test_collection = (GeeCollection*) _tmp0_;
	_tmp1_ = ((ReadOnlyCollectionTests*) self)->test_collection;
	_tmp2_ = read_only_collection_tests_get_ro_view ((ReadOnlyCollectionTests*) self, _tmp1_);
	_g_object_unref0 (((ReadOnlyCollectionTests*) self)->ro_collection);
	((ReadOnlyCollectionTests*) self)->ro_collection = _tmp2_;
}


static void read_only_list_tests_real_tear_down (GeeTestCase* base) {
	ReadOnlyListTests * self;
	self = (ReadOnlyListTests*) base;
	_g_object_unref0 (((ReadOnlyCollectionTests*) self)->test_collection);
	((ReadOnlyCollectionTests*) self)->test_collection = NULL;
	_g_object_unref0 (((ReadOnlyCollectionTests*) self)->ro_collection);
	((ReadOnlyCollectionTests*) self)->ro_collection = NULL;
}


static GeeCollection* read_only_list_tests_real_get_ro_view (ReadOnlyCollectionTests* base, GeeCollection* collection) {
	ReadOnlyListTests * self;
	GeeCollection* result = NULL;
	GeeCollection* _tmp0_;
	GeeList* _tmp1_;
	GeeList* _tmp2_;
	self = (ReadOnlyListTests*) base;
	g_return_val_if_fail (collection != NULL, NULL);
	_tmp0_ = collection;
	_tmp1_ = gee_list_get_read_only_view (GEE_LIST (_tmp0_));
	_tmp2_ = _tmp1_;
	result = (GeeCollection*) _tmp2_;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void read_only_list_tests_test_immutable_iterator (ReadOnlyListTests* self) {
	GeeCollection* _tmp0_;
	GeeList* _tmp1_;
	GeeList* test_list;
	GeeCollection* _tmp2_;
	GeeList* _tmp3_;
	GeeList* ro_list;
	GeeList* _tmp4_;
	gboolean _tmp5_ = FALSE;
	GeeList* _tmp6_;
	gboolean _tmp7_ = FALSE;
	GeeList* _tmp8_;
	gint _tmp9_;
	gint _tmp10_;
	GeeList* _tmp11_;
	gpointer _tmp12_ = NULL;
	gchar* _tmp13_;
	GeeList* _tmp14_;
	gpointer _tmp15_ = NULL;
	gchar* _tmp16_;
	GeeList* _tmp17_;
	GeeListIterator* _tmp18_ = NULL;
	GeeListIterator* iterator;
	GeeListIterator* _tmp19_;
	gboolean _tmp20_ = FALSE;
	GeeListIterator* _tmp21_;
	gboolean _tmp22_ = FALSE;
	GeeListIterator* _tmp23_;
	gpointer _tmp24_ = NULL;
	gchar* _tmp25_;
	GeeListIterator* _tmp26_;
	gint _tmp27_ = 0;
	GeeListIterator* _tmp28_;
	gboolean _tmp29_ = FALSE;
	GeeListIterator* _tmp30_;
	gboolean _tmp31_ = FALSE;
	GeeListIterator* _tmp32_;
	gpointer _tmp33_ = NULL;
	gchar* _tmp34_;
	GeeListIterator* _tmp35_;
	gint _tmp36_ = 0;
	GeeListIterator* _tmp37_;
	gboolean _tmp38_ = FALSE;
	GeeListIterator* _tmp39_;
	gboolean _tmp40_ = FALSE;
	GeeListIterator* _tmp41_;
	gboolean _tmp42_ = FALSE;
	GeeListIterator* _tmp43_;
	gboolean _tmp44_ = FALSE;
	GeeListIterator* _tmp45_;
	gpointer _tmp46_ = NULL;
	gchar* _tmp47_;
	GeeListIterator* _tmp48_;
	gint _tmp49_ = 0;
	GeeListIterator* _tmp50_;
	gboolean _tmp51_ = FALSE;
	GeeListIterator* _tmp52_;
	gpointer _tmp53_ = NULL;
	gchar* _tmp54_;
	GeeListIterator* _tmp55_;
	gint _tmp56_ = 0;
	GeeListIterator* _tmp57_;
	gboolean _tmp58_ = FALSE;
	GeeListIterator* _tmp59_;
	gpointer _tmp60_ = NULL;
	gchar* _tmp61_;
	GeeListIterator* _tmp62_;
	gint _tmp63_ = 0;
	gboolean _tmp64_ = FALSE;
	GeeList* _tmp66_;
	gint _tmp67_;
	gint _tmp68_;
	GeeList* _tmp69_;
	gpointer _tmp70_ = NULL;
	gchar* _tmp71_;
	GeeList* _tmp72_;
	gpointer _tmp73_ = NULL;
	gchar* _tmp74_;
	GeeListIterator* _tmp75_;
	gint _tmp76_ = 0;
	gboolean _tmp77_ = FALSE;
	GeeList* _tmp79_;
	gint _tmp80_;
	gint _tmp81_;
	GeeList* _tmp82_;
	gpointer _tmp83_ = NULL;
	gchar* _tmp84_;
	GeeList* _tmp85_;
	gpointer _tmp86_ = NULL;
	gchar* _tmp87_;
	GeeListIterator* _tmp88_;
	gint _tmp89_ = 0;
	gboolean _tmp90_ = FALSE;
	GeeList* _tmp92_;
	gint _tmp93_;
	gint _tmp94_;
	GeeList* _tmp95_;
	gpointer _tmp96_ = NULL;
	gchar* _tmp97_;
	GeeList* _tmp98_;
	gpointer _tmp99_ = NULL;
	gchar* _tmp100_;
	GeeListIterator* _tmp101_;
	gint _tmp102_ = 0;
	gboolean _tmp103_ = FALSE;
	GeeList* _tmp105_;
	gint _tmp106_;
	gint _tmp107_;
	GeeList* _tmp108_;
	gpointer _tmp109_ = NULL;
	gchar* _tmp110_;
	GeeList* _tmp111_;
	gpointer _tmp112_ = NULL;
	gchar* _tmp113_;
	GeeListIterator* _tmp114_;
	gint _tmp115_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = ((ReadOnlyCollectionTests*) self)->test_collection;
	_tmp1_ = _g_object_ref0 (GEE_IS_LIST (_tmp0_) ? ((GeeList*) _tmp0_) : NULL);
	test_list = _tmp1_;
	_tmp2_ = ((ReadOnlyCollectionTests*) self)->ro_collection;
	_tmp3_ = _g_object_ref0 (GEE_IS_LIST (_tmp2_) ? ((GeeList*) _tmp2_) : NULL);
	ro_list = _tmp3_;
	_tmp4_ = test_list;
	_tmp5_ = gee_collection_add ((GeeCollection*) _tmp4_, "one");
	g_assert (_tmp5_);
	_tmp6_ = test_list;
	_tmp7_ = gee_collection_add ((GeeCollection*) _tmp6_, "two");
	g_assert (_tmp7_);
	_tmp8_ = ro_list;
	_tmp9_ = gee_collection_get_size ((GeeCollection*) _tmp8_);
	_tmp10_ = _tmp9_;
	g_assert (_tmp10_ == 2);
	_tmp11_ = ro_list;
	_tmp12_ = gee_list_get (_tmp11_, 0);
	_tmp13_ = (gchar*) _tmp12_;
	g_assert (g_strcmp0 (_tmp13_, "one") == 0);
	_g_free0 (_tmp13_);
	_tmp14_ = ro_list;
	_tmp15_ = gee_list_get (_tmp14_, 1);
	_tmp16_ = (gchar*) _tmp15_;
	g_assert (g_strcmp0 (_tmp16_, "two") == 0);
	_g_free0 (_tmp16_);
	_tmp17_ = ro_list;
	_tmp18_ = gee_list_list_iterator (_tmp17_);
	iterator = _tmp18_;
	_tmp19_ = iterator;
	_tmp20_ = gee_iterator_has_next ((GeeIterator*) _tmp19_);
	g_assert (_tmp20_);
	_tmp21_ = iterator;
	_tmp22_ = gee_iterator_next ((GeeIterator*) _tmp21_);
	g_assert (_tmp22_);
	_tmp23_ = iterator;
	_tmp24_ = gee_iterator_get ((GeeIterator*) _tmp23_);
	_tmp25_ = (gchar*) _tmp24_;
	g_assert (g_strcmp0 (_tmp25_, "one") == 0);
	_g_free0 (_tmp25_);
	_tmp26_ = iterator;
	_tmp27_ = gee_list_iterator_index (_tmp26_);
	g_assert (_tmp27_ == 0);
	_tmp28_ = iterator;
	_tmp29_ = gee_iterator_has_next ((GeeIterator*) _tmp28_);
	g_assert (_tmp29_);
	_tmp30_ = iterator;
	_tmp31_ = gee_iterator_next ((GeeIterator*) _tmp30_);
	g_assert (_tmp31_);
	_tmp32_ = iterator;
	_tmp33_ = gee_iterator_get ((GeeIterator*) _tmp32_);
	_tmp34_ = (gchar*) _tmp33_;
	g_assert (g_strcmp0 (_tmp34_, "two") == 0);
	_g_free0 (_tmp34_);
	_tmp35_ = iterator;
	_tmp36_ = gee_list_iterator_index (_tmp35_);
	g_assert (_tmp36_ == 1);
	_tmp37_ = iterator;
	_tmp38_ = gee_iterator_has_next ((GeeIterator*) _tmp37_);
	g_assert (!_tmp38_);
	_tmp39_ = iterator;
	_tmp40_ = gee_iterator_next ((GeeIterator*) _tmp39_);
	g_assert (!_tmp40_);
	_tmp41_ = iterator;
	_tmp42_ = gee_bidir_iterator_has_previous ((GeeBidirIterator*) _tmp41_);
	g_assert (_tmp42_);
	_tmp43_ = iterator;
	_tmp44_ = gee_bidir_iterator_previous ((GeeBidirIterator*) _tmp43_);
	g_assert (_tmp44_);
	_tmp45_ = iterator;
	_tmp46_ = gee_iterator_get ((GeeIterator*) _tmp45_);
	_tmp47_ = (gchar*) _tmp46_;
	g_assert (g_strcmp0 (_tmp47_, "one") == 0);
	_g_free0 (_tmp47_);
	_tmp48_ = iterator;
	_tmp49_ = gee_list_iterator_index (_tmp48_);
	g_assert (_tmp49_ == 0);
	_tmp50_ = iterator;
	_tmp51_ = gee_bidir_iterator_last ((GeeBidirIterator*) _tmp50_);
	g_assert (_tmp51_);
	_tmp52_ = iterator;
	_tmp53_ = gee_iterator_get ((GeeIterator*) _tmp52_);
	_tmp54_ = (gchar*) _tmp53_;
	g_assert (g_strcmp0 (_tmp54_, "two") == 0);
	_g_free0 (_tmp54_);
	_tmp55_ = iterator;
	_tmp56_ = gee_list_iterator_index (_tmp55_);
	g_assert (_tmp56_ == 1);
	_tmp57_ = iterator;
	_tmp58_ = gee_iterator_first ((GeeIterator*) _tmp57_);
	g_assert (_tmp58_);
	_tmp59_ = iterator;
	_tmp60_ = gee_iterator_get ((GeeIterator*) _tmp59_);
	_tmp61_ = (gchar*) _tmp60_;
	g_assert (g_strcmp0 (_tmp61_, "one") == 0);
	_g_free0 (_tmp61_);
	_tmp62_ = iterator;
	_tmp63_ = gee_list_iterator_index (_tmp62_);
	g_assert (_tmp63_ == 0);
	_tmp64_ = g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR);
	if (_tmp64_) {
		GeeListIterator* _tmp65_;
		_tmp65_ = iterator;
		gee_iterator_remove ((GeeIterator*) _tmp65_);
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp66_ = ro_list;
	_tmp67_ = gee_collection_get_size ((GeeCollection*) _tmp66_);
	_tmp68_ = _tmp67_;
	g_assert (_tmp68_ == 2);
	_tmp69_ = ro_list;
	_tmp70_ = gee_list_get (_tmp69_, 0);
	_tmp71_ = (gchar*) _tmp70_;
	g_assert (g_strcmp0 (_tmp71_, "one") == 0);
	_g_free0 (_tmp71_);
	_tmp72_ = ro_list;
	_tmp73_ = gee_list_get (_tmp72_, 1);
	_tmp74_ = (gchar*) _tmp73_;
	g_assert (g_strcmp0 (_tmp74_, "two") == 0);
	_g_free0 (_tmp74_);
	_tmp75_ = iterator;
	_tmp76_ = gee_list_iterator_index (_tmp75_);
	g_assert (_tmp76_ == 0);
	_tmp77_ = g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR);
	if (_tmp77_) {
		GeeListIterator* _tmp78_;
		_tmp78_ = iterator;
		gee_list_iterator_set (_tmp78_, "three");
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp79_ = ro_list;
	_tmp80_ = gee_collection_get_size ((GeeCollection*) _tmp79_);
	_tmp81_ = _tmp80_;
	g_assert (_tmp81_ == 2);
	_tmp82_ = ro_list;
	_tmp83_ = gee_list_get (_tmp82_, 0);
	_tmp84_ = (gchar*) _tmp83_;
	g_assert (g_strcmp0 (_tmp84_, "one") == 0);
	_g_free0 (_tmp84_);
	_tmp85_ = ro_list;
	_tmp86_ = gee_list_get (_tmp85_, 1);
	_tmp87_ = (gchar*) _tmp86_;
	g_assert (g_strcmp0 (_tmp87_, "two") == 0);
	_g_free0 (_tmp87_);
	_tmp88_ = iterator;
	_tmp89_ = gee_list_iterator_index (_tmp88_);
	g_assert (_tmp89_ == 0);
	_tmp90_ = g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR);
	if (_tmp90_) {
		GeeListIterator* _tmp91_;
		_tmp91_ = iterator;
		gee_list_iterator_insert (_tmp91_, "three");
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp92_ = ro_list;
	_tmp93_ = gee_collection_get_size ((GeeCollection*) _tmp92_);
	_tmp94_ = _tmp93_;
	g_assert (_tmp94_ == 2);
	_tmp95_ = ro_list;
	_tmp96_ = gee_list_get (_tmp95_, 0);
	_tmp97_ = (gchar*) _tmp96_;
	g_assert (g_strcmp0 (_tmp97_, "one") == 0);
	_g_free0 (_tmp97_);
	_tmp98_ = ro_list;
	_tmp99_ = gee_list_get (_tmp98_, 1);
	_tmp100_ = (gchar*) _tmp99_;
	g_assert (g_strcmp0 (_tmp100_, "two") == 0);
	_g_free0 (_tmp100_);
	_tmp101_ = iterator;
	_tmp102_ = gee_list_iterator_index (_tmp101_);
	g_assert (_tmp102_ == 0);
	_tmp103_ = g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR);
	if (_tmp103_) {
		GeeListIterator* _tmp104_;
		_tmp104_ = iterator;
		gee_list_iterator_add (_tmp104_, "three");
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp105_ = ro_list;
	_tmp106_ = gee_collection_get_size ((GeeCollection*) _tmp105_);
	_tmp107_ = _tmp106_;
	g_assert (_tmp107_ == 2);
	_tmp108_ = ro_list;
	_tmp109_ = gee_list_get (_tmp108_, 0);
	_tmp110_ = (gchar*) _tmp109_;
	g_assert (g_strcmp0 (_tmp110_, "one") == 0);
	_g_free0 (_tmp110_);
	_tmp111_ = ro_list;
	_tmp112_ = gee_list_get (_tmp111_, 1);
	_tmp113_ = (gchar*) _tmp112_;
	g_assert (g_strcmp0 (_tmp113_, "two") == 0);
	_g_free0 (_tmp113_);
	_tmp114_ = iterator;
	_tmp115_ = gee_list_iterator_index (_tmp114_);
	g_assert (_tmp115_ == 0);
	_g_object_unref0 (iterator);
	_g_object_unref0 (ro_list);
	_g_object_unref0 (test_list);
}


void read_only_list_tests_test_immutable (ReadOnlyListTests* self) {
	GeeCollection* _tmp0_;
	GeeList* _tmp1_;
	GeeList* test_list;
	GeeCollection* _tmp2_;
	GeeList* _tmp3_;
	GeeList* ro_list;
	GeeList* _tmp4_;
	gboolean _tmp5_ = FALSE;
	GeeList* _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	GeeList* _tmp9_;
	gboolean _tmp10_ = FALSE;
	GeeArrayList* _tmp11_;
	GeeCollection* dummy;
	GeeCollection* _tmp12_;
	gboolean _tmp13_ = FALSE;
	GeeCollection* _tmp14_;
	gboolean _tmp15_ = FALSE;
	gboolean _tmp16_ = FALSE;
	GeeList* _tmp18_;
	gint _tmp19_;
	gint _tmp20_;
	GeeList* _tmp21_;
	gboolean _tmp22_ = FALSE;
	gboolean _tmp23_ = FALSE;
	GeeList* _tmp25_;
	gint _tmp26_;
	gint _tmp27_;
	GeeList* _tmp28_;
	gboolean _tmp29_ = FALSE;
	gboolean _tmp30_ = FALSE;
	GeeList* _tmp34_;
	gint _tmp35_;
	gint _tmp36_;
	GeeList* _tmp37_;
	gboolean _tmp38_ = FALSE;
	gboolean _tmp39_ = FALSE;
	GeeList* _tmp42_;
	gint _tmp43_;
	gint _tmp44_;
	GeeList* _tmp45_;
	gboolean _tmp46_ = FALSE;
	gboolean _tmp47_ = FALSE;
	GeeList* _tmp49_;
	gint _tmp50_;
	gint _tmp51_;
	GeeList* _tmp52_;
	gboolean _tmp53_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = ((ReadOnlyCollectionTests*) self)->test_collection;
	_tmp1_ = _g_object_ref0 (GEE_IS_LIST (_tmp0_) ? ((GeeList*) _tmp0_) : NULL);
	test_list = _tmp1_;
	_tmp2_ = ((ReadOnlyCollectionTests*) self)->ro_collection;
	_tmp3_ = _g_object_ref0 (GEE_IS_LIST (_tmp2_) ? ((GeeList*) _tmp2_) : NULL);
	ro_list = _tmp3_;
	_tmp4_ = test_list;
	_tmp5_ = gee_collection_add ((GeeCollection*) _tmp4_, "one");
	g_assert (_tmp5_);
	_tmp6_ = ro_list;
	_tmp7_ = gee_collection_get_size ((GeeCollection*) _tmp6_);
	_tmp8_ = _tmp7_;
	g_assert (_tmp8_ == 1);
	_tmp9_ = ro_list;
	_tmp10_ = gee_collection_contains ((GeeCollection*) _tmp9_, "one");
	g_assert (_tmp10_);
	_tmp11_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL);
	dummy = (GeeCollection*) _tmp11_;
	_tmp12_ = dummy;
	_tmp13_ = gee_collection_add (_tmp12_, "one");
	g_assert (_tmp13_);
	_tmp14_ = dummy;
	_tmp15_ = gee_collection_add (_tmp14_, "two");
	g_assert (_tmp15_);
	_tmp16_ = g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR);
	if (_tmp16_) {
		GeeList* _tmp17_;
		_tmp17_ = ro_list;
		gee_list_set (_tmp17_, 0, "two");
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp18_ = ro_list;
	_tmp19_ = gee_collection_get_size ((GeeCollection*) _tmp18_);
	_tmp20_ = _tmp19_;
	g_assert (_tmp20_ == 1);
	_tmp21_ = ro_list;
	_tmp22_ = gee_collection_contains ((GeeCollection*) _tmp21_, "one");
	g_assert (_tmp22_);
	_tmp23_ = g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR);
	if (_tmp23_) {
		GeeList* _tmp24_;
		_tmp24_ = ro_list;
		gee_list_insert (_tmp24_, 1, "two");
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp25_ = ro_list;
	_tmp26_ = gee_collection_get_size ((GeeCollection*) _tmp25_);
	_tmp27_ = _tmp26_;
	g_assert (_tmp27_ == 1);
	_tmp28_ = ro_list;
	_tmp29_ = gee_collection_contains ((GeeCollection*) _tmp28_, "one");
	g_assert (_tmp29_);
	_tmp30_ = g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR);
	if (_tmp30_) {
		GeeList* _tmp31_;
		gpointer _tmp32_ = NULL;
		gchar* _tmp33_;
		_tmp31_ = ro_list;
		_tmp32_ = gee_list_remove_at (_tmp31_, 1);
		_tmp33_ = (gchar*) _tmp32_;
		_g_free0 (_tmp33_);
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp34_ = ro_list;
	_tmp35_ = gee_collection_get_size ((GeeCollection*) _tmp34_);
	_tmp36_ = _tmp35_;
	g_assert (_tmp36_ == 1);
	_tmp37_ = ro_list;
	_tmp38_ = gee_collection_contains ((GeeCollection*) _tmp37_, "one");
	g_assert (_tmp38_);
	_tmp39_ = g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR);
	if (_tmp39_) {
		GeeList* _tmp40_;
		GeeCollection* _tmp41_;
		_tmp40_ = ro_list;
		_tmp41_ = dummy;
		gee_list_insert_all (_tmp40_, 1, _tmp41_);
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp42_ = ro_list;
	_tmp43_ = gee_collection_get_size ((GeeCollection*) _tmp42_);
	_tmp44_ = _tmp43_;
	g_assert (_tmp44_ == 1);
	_tmp45_ = ro_list;
	_tmp46_ = gee_collection_contains ((GeeCollection*) _tmp45_, "one");
	g_assert (_tmp46_);
	_tmp47_ = g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR);
	if (_tmp47_) {
		GeeList* _tmp48_;
		_tmp48_ = ro_list;
		gee_list_sort (_tmp48_, NULL);
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp49_ = ro_list;
	_tmp50_ = gee_collection_get_size ((GeeCollection*) _tmp49_);
	_tmp51_ = _tmp50_;
	g_assert (_tmp51_ == 1);
	_tmp52_ = ro_list;
	_tmp53_ = gee_collection_contains ((GeeCollection*) _tmp52_, "one");
	g_assert (_tmp53_);
	_g_object_unref0 (dummy);
	_g_object_unref0 (ro_list);
	_g_object_unref0 (test_list);
}


void read_only_list_tests_test_accurate_view (ReadOnlyListTests* self) {
	GeeCollection* _tmp0_;
	GeeList* _tmp1_;
	GeeList* test_list;
	GeeCollection* _tmp2_;
	GeeList* _tmp3_;
	GeeList* ro_list;
	GeeArrayList* _tmp4_;
	GeeCollection* dummy;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	GType _tmp7_;
	GType _tmp8_;
	gint _tmp9_;
	gint _tmp10_;
	gboolean _tmp11_;
	gboolean _tmp12_;
	gboolean _tmp13_ = FALSE;
	gint _tmp14_ = 0;
	gboolean _tmp15_ = FALSE;
	gint _tmp16_;
	gint _tmp17_;
	gboolean _tmp18_;
	gboolean _tmp19_;
	gpointer _tmp20_ = NULL;
	gchar* _tmp21_;
	gint _tmp22_ = 0;
	gpointer _tmp23_ = NULL;
	gchar* _tmp24_;
	gpointer _tmp25_ = NULL;
	gchar* _tmp26_;
	gboolean _tmp27_ = FALSE;
	gint _tmp28_;
	gint _tmp29_;
	gboolean _tmp30_;
	gboolean _tmp31_;
	gpointer _tmp32_ = NULL;
	gchar* _tmp33_;
	gint _tmp34_ = 0;
	gpointer _tmp35_ = NULL;
	gchar* _tmp36_;
	gint _tmp37_ = 0;
	gpointer _tmp38_ = NULL;
	gchar* _tmp39_;
	gpointer _tmp40_ = NULL;
	gchar* _tmp41_;
	gboolean _tmp42_ = FALSE;
	gint _tmp43_;
	gint _tmp44_;
	gboolean _tmp45_;
	gboolean _tmp46_;
	gboolean _tmp47_ = FALSE;
	gint _tmp48_ = 0;
	gboolean _tmp49_ = FALSE;
	gpointer _tmp50_ = NULL;
	gchar* _tmp51_;
	gint _tmp52_ = 0;
	gpointer _tmp53_ = NULL;
	gchar* _tmp54_;
	gpointer _tmp55_ = NULL;
	gchar* _tmp56_;
	gint _tmp57_;
	gint _tmp58_;
	gboolean _tmp59_;
	gboolean _tmp60_;
	gint _tmp61_ = 0;
	gint _tmp62_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = ((ReadOnlyCollectionTests*) self)->test_collection;
	_tmp1_ = _g_object_ref0 (GEE_IS_LIST (_tmp0_) ? ((GeeList*) _tmp0_) : NULL);
	test_list = _tmp1_;
	_tmp2_ = ((ReadOnlyCollectionTests*) self)->ro_collection;
	_tmp3_ = _g_object_ref0 (GEE_IS_LIST (_tmp2_) ? ((GeeList*) _tmp2_) : NULL);
	ro_list = _tmp3_;
	_tmp4_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL);
	dummy = (GeeCollection*) _tmp4_;
	_tmp5_ = gee_collection_add (dummy, "one");
	g_assert (_tmp5_);
	_tmp6_ = gee_collection_add (dummy, "two");
	g_assert (_tmp6_);
	_tmp7_ = gee_iterable_get_element_type ((GeeIterable*) ro_list);
	_tmp8_ = _tmp7_;
	g_assert (_tmp8_ == G_TYPE_STRING);
	_tmp9_ = gee_collection_get_size ((GeeCollection*) ro_list);
	_tmp10_ = _tmp9_;
	g_assert (_tmp10_ == 0);
	_tmp11_ = gee_collection_get_is_empty ((GeeCollection*) ro_list);
	_tmp12_ = _tmp11_;
	g_assert (_tmp12_);
	_tmp13_ = gee_collection_contains ((GeeCollection*) ro_list, "one");
	g_assert (!_tmp13_);
	_tmp14_ = gee_list_index_of (ro_list, "one");
	g_assert (_tmp14_ == (-1));
	_tmp15_ = gee_collection_add ((GeeCollection*) test_list, "one");
	g_assert (_tmp15_);
	_tmp16_ = gee_collection_get_size ((GeeCollection*) ro_list);
	_tmp17_ = _tmp16_;
	g_assert (_tmp17_ == 1);
	_tmp18_ = gee_collection_get_is_empty ((GeeCollection*) ro_list);
	_tmp19_ = _tmp18_;
	g_assert (!_tmp19_);
	_tmp20_ = gee_list_get (ro_list, 0);
	_tmp21_ = (gchar*) _tmp20_;
	g_assert (g_strcmp0 (_tmp21_, "one") == 0);
	_g_free0 (_tmp21_);
	_tmp22_ = gee_list_index_of (ro_list, "one");
	g_assert (_tmp22_ == 0);
	_tmp23_ = gee_list_first (ro_list);
	_tmp24_ = (gchar*) _tmp23_;
	g_assert (g_strcmp0 (_tmp24_, "one") == 0);
	_g_free0 (_tmp24_);
	_tmp25_ = gee_list_last (ro_list);
	_tmp26_ = (gchar*) _tmp25_;
	g_assert (g_strcmp0 (_tmp26_, "one") == 0);
	_g_free0 (_tmp26_);
	_tmp27_ = gee_collection_add ((GeeCollection*) test_list, "two");
	g_assert (_tmp27_);
	_tmp28_ = gee_collection_get_size ((GeeCollection*) ro_list);
	_tmp29_ = _tmp28_;
	g_assert (_tmp29_ == 2);
	_tmp30_ = gee_collection_get_is_empty ((GeeCollection*) ro_list);
	_tmp31_ = _tmp30_;
	g_assert (!_tmp31_);
	_tmp32_ = gee_list_get (ro_list, 0);
	_tmp33_ = (gchar*) _tmp32_;
	g_assert (g_strcmp0 (_tmp33_, "one") == 0);
	_g_free0 (_tmp33_);
	_tmp34_ = gee_list_index_of (ro_list, "one");
	g_assert (_tmp34_ == 0);
	_tmp35_ = gee_list_get (ro_list, 1);
	_tmp36_ = (gchar*) _tmp35_;
	g_assert (g_strcmp0 (_tmp36_, "two") == 0);
	_g_free0 (_tmp36_);
	_tmp37_ = gee_list_index_of (ro_list, "two");
	g_assert (_tmp37_ == 1);
	_tmp38_ = gee_list_first (ro_list);
	_tmp39_ = (gchar*) _tmp38_;
	g_assert (g_strcmp0 (_tmp39_, "one") == 0);
	_g_free0 (_tmp39_);
	_tmp40_ = gee_list_last (ro_list);
	_tmp41_ = (gchar*) _tmp40_;
	g_assert (g_strcmp0 (_tmp41_, "two") == 0);
	_g_free0 (_tmp41_);
	_tmp42_ = gee_collection_remove ((GeeCollection*) test_list, "one");
	g_assert (_tmp42_);
	_tmp43_ = gee_collection_get_size ((GeeCollection*) ro_list);
	_tmp44_ = _tmp43_;
	g_assert (_tmp44_ == 1);
	_tmp45_ = gee_collection_get_is_empty ((GeeCollection*) ro_list);
	_tmp46_ = _tmp45_;
	g_assert (!_tmp46_);
	_tmp47_ = gee_collection_contains ((GeeCollection*) ro_list, "one");
	g_assert (!_tmp47_);
	_tmp48_ = gee_list_index_of (ro_list, "one");
	g_assert (_tmp48_ == (-1));
	_tmp49_ = gee_collection_contains ((GeeCollection*) ro_list, "two");
	g_assert (_tmp49_);
	_tmp50_ = gee_list_get (ro_list, 0);
	_tmp51_ = (gchar*) _tmp50_;
	g_assert (g_strcmp0 (_tmp51_, "two") == 0);
	_g_free0 (_tmp51_);
	_tmp52_ = gee_list_index_of (ro_list, "two");
	g_assert (_tmp52_ == 0);
	_tmp53_ = gee_list_first (ro_list);
	_tmp54_ = (gchar*) _tmp53_;
	g_assert (g_strcmp0 (_tmp54_, "two") == 0);
	_g_free0 (_tmp54_);
	_tmp55_ = gee_list_last (ro_list);
	_tmp56_ = (gchar*) _tmp55_;
	g_assert (g_strcmp0 (_tmp56_, "two") == 0);
	_g_free0 (_tmp56_);
	gee_collection_clear ((GeeCollection*) test_list);
	_tmp57_ = gee_collection_get_size ((GeeCollection*) ro_list);
	_tmp58_ = _tmp57_;
	g_assert (_tmp58_ == 0);
	_tmp59_ = gee_collection_get_is_empty ((GeeCollection*) ro_list);
	_tmp60_ = _tmp59_;
	g_assert (_tmp60_);
	_tmp61_ = gee_list_index_of (ro_list, "one");
	g_assert (_tmp61_ == (-1));
	_tmp62_ = gee_list_index_of (ro_list, "two");
	g_assert (_tmp62_ == (-1));
	_g_object_unref0 (dummy);
	_g_object_unref0 (ro_list);
	_g_object_unref0 (test_list);
}


static void read_only_list_tests_class_init (ReadOnlyListTestsClass * klass) {
	read_only_list_tests_parent_class = g_type_class_peek_parent (klass);
	GEE_TEST_CASE_CLASS (klass)->set_up = read_only_list_tests_real_set_up;
	GEE_TEST_CASE_CLASS (klass)->tear_down = read_only_list_tests_real_tear_down;
	READ_ONLY_COLLECTION_TESTS_CLASS (klass)->get_ro_view = read_only_list_tests_real_get_ro_view;
}


static void read_only_list_tests_instance_init (ReadOnlyListTests * self) {
}


GType read_only_list_tests_get_type (void) {
	static volatile gsize read_only_list_tests_type_id__volatile = 0;
	if (g_once_init_enter (&read_only_list_tests_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ReadOnlyListTestsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) read_only_list_tests_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ReadOnlyListTests), 0, (GInstanceInitFunc) read_only_list_tests_instance_init, NULL };
		GType read_only_list_tests_type_id;
		read_only_list_tests_type_id = g_type_register_static (TYPE_READ_ONLY_COLLECTION_TESTS, "ReadOnlyListTests", &g_define_type_info, 0);
		g_once_init_leave (&read_only_list_tests_type_id__volatile, read_only_list_tests_type_id);
	}
	return read_only_list_tests_type_id__volatile;
}



