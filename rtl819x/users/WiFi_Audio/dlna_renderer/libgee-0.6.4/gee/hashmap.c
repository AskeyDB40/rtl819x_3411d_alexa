/* hashmap.c generated by valac 0.15.0.90-e9553, the Vala compiler
 * generated from hashmap.vala, do not modify */

/* hashmap.vala
 *
 * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
 * Copyright (C) 1997-2000  GLib Team and others
 * Copyright (C) 2007-2009  Jürg Billeter
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Jürg Billeter <j@bitron.ch>
 */

#include <glib.h>
#include <glib-object.h>


#define GEE_TYPE_ITERABLE (gee_iterable_get_type ())
#define GEE_ITERABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_ITERABLE, GeeIterable))
#define GEE_IS_ITERABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_ITERABLE))
#define GEE_ITERABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GEE_TYPE_ITERABLE, GeeIterableIface))

typedef struct _GeeIterable GeeIterable;
typedef struct _GeeIterableIface GeeIterableIface;

#define GEE_TYPE_ITERATOR (gee_iterator_get_type ())
#define GEE_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_ITERATOR, GeeIterator))
#define GEE_IS_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_ITERATOR))
#define GEE_ITERATOR_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GEE_TYPE_ITERATOR, GeeIteratorIface))

typedef struct _GeeIterator GeeIterator;
typedef struct _GeeIteratorIface GeeIteratorIface;

#define GEE_TYPE_MAP (gee_map_get_type ())
#define GEE_MAP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_MAP, GeeMap))
#define GEE_IS_MAP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_MAP))
#define GEE_MAP_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GEE_TYPE_MAP, GeeMapIface))

typedef struct _GeeMap GeeMap;
typedef struct _GeeMapIface GeeMapIface;

#define GEE_TYPE_MAP_ITERATOR (gee_map_iterator_get_type ())
#define GEE_MAP_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_MAP_ITERATOR, GeeMapIterator))
#define GEE_IS_MAP_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_MAP_ITERATOR))
#define GEE_MAP_ITERATOR_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GEE_TYPE_MAP_ITERATOR, GeeMapIteratorIface))

typedef struct _GeeMapIterator GeeMapIterator;
typedef struct _GeeMapIteratorIface GeeMapIteratorIface;

#define GEE_TYPE_COLLECTION (gee_collection_get_type ())
#define GEE_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_COLLECTION, GeeCollection))
#define GEE_IS_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_COLLECTION))
#define GEE_COLLECTION_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GEE_TYPE_COLLECTION, GeeCollectionIface))

typedef struct _GeeCollection GeeCollection;
typedef struct _GeeCollectionIface GeeCollectionIface;

#define GEE_TYPE_SET (gee_set_get_type ())
#define GEE_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_SET, GeeSet))
#define GEE_IS_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_SET))
#define GEE_SET_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GEE_TYPE_SET, GeeSetIface))

typedef struct _GeeSet GeeSet;
typedef struct _GeeSetIface GeeSetIface;

#define GEE_MAP_TYPE_ENTRY (gee_map_entry_get_type ())
#define GEE_MAP_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_MAP_TYPE_ENTRY, GeeMapEntry))
#define GEE_MAP_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_MAP_TYPE_ENTRY, GeeMapEntryClass))
#define GEE_MAP_IS_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_MAP_TYPE_ENTRY))
#define GEE_MAP_IS_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_MAP_TYPE_ENTRY))
#define GEE_MAP_ENTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_MAP_TYPE_ENTRY, GeeMapEntryClass))

typedef struct _GeeMapEntry GeeMapEntry;
typedef struct _GeeMapEntryClass GeeMapEntryClass;

#define GEE_TYPE_ABSTRACT_MAP (gee_abstract_map_get_type ())
#define GEE_ABSTRACT_MAP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_ABSTRACT_MAP, GeeAbstractMap))
#define GEE_ABSTRACT_MAP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_ABSTRACT_MAP, GeeAbstractMapClass))
#define GEE_IS_ABSTRACT_MAP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_ABSTRACT_MAP))
#define GEE_IS_ABSTRACT_MAP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_ABSTRACT_MAP))
#define GEE_ABSTRACT_MAP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_ABSTRACT_MAP, GeeAbstractMapClass))

typedef struct _GeeAbstractMap GeeAbstractMap;
typedef struct _GeeAbstractMapClass GeeAbstractMapClass;
typedef struct _GeeAbstractMapPrivate GeeAbstractMapPrivate;

#define GEE_TYPE_HASH_MAP (gee_hash_map_get_type ())
#define GEE_HASH_MAP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_HASH_MAP, GeeHashMap))
#define GEE_HASH_MAP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_HASH_MAP, GeeHashMapClass))
#define GEE_IS_HASH_MAP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_HASH_MAP))
#define GEE_IS_HASH_MAP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_HASH_MAP))
#define GEE_HASH_MAP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_HASH_MAP, GeeHashMapClass))

typedef struct _GeeHashMap GeeHashMap;
typedef struct _GeeHashMapClass GeeHashMapClass;
typedef struct _GeeHashMapPrivate GeeHashMapPrivate;
typedef struct _GeeHashMapNode GeeHashMapNode;
#define _gee_hash_map_node_free0(var) ((var == NULL) ? NULL : (var = (gee_hash_map_node_free (var), NULL)))

#define GEE_HASH_MAP_TYPE_NODE_ITERATOR (gee_hash_map_node_iterator_get_type ())
#define GEE_HASH_MAP_NODE_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_HASH_MAP_TYPE_NODE_ITERATOR, GeeHashMapNodeIterator))
#define GEE_HASH_MAP_NODE_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_HASH_MAP_TYPE_NODE_ITERATOR, GeeHashMapNodeIteratorClass))
#define GEE_HASH_MAP_IS_NODE_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_HASH_MAP_TYPE_NODE_ITERATOR))
#define GEE_HASH_MAP_IS_NODE_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_HASH_MAP_TYPE_NODE_ITERATOR))
#define GEE_HASH_MAP_NODE_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_HASH_MAP_TYPE_NODE_ITERATOR, GeeHashMapNodeIteratorClass))

typedef struct _GeeHashMapNodeIterator GeeHashMapNodeIterator;
typedef struct _GeeHashMapNodeIteratorClass GeeHashMapNodeIteratorClass;

#define GEE_HASH_MAP_TYPE_MAP_ITERATOR (gee_hash_map_map_iterator_get_type ())
#define GEE_HASH_MAP_MAP_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_HASH_MAP_TYPE_MAP_ITERATOR, GeeHashMapMapIterator))
#define GEE_HASH_MAP_MAP_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_HASH_MAP_TYPE_MAP_ITERATOR, GeeHashMapMapIteratorClass))
#define GEE_HASH_MAP_IS_MAP_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_HASH_MAP_TYPE_MAP_ITERATOR))
#define GEE_HASH_MAP_IS_MAP_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_HASH_MAP_TYPE_MAP_ITERATOR))
#define GEE_HASH_MAP_MAP_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_HASH_MAP_TYPE_MAP_ITERATOR, GeeHashMapMapIteratorClass))

typedef struct _GeeHashMapMapIterator GeeHashMapMapIterator;
typedef struct _GeeHashMapMapIteratorClass GeeHashMapMapIteratorClass;

#define GEE_TYPE_ABSTRACT_COLLECTION (gee_abstract_collection_get_type ())
#define GEE_ABSTRACT_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_ABSTRACT_COLLECTION, GeeAbstractCollection))
#define GEE_ABSTRACT_COLLECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_ABSTRACT_COLLECTION, GeeAbstractCollectionClass))
#define GEE_IS_ABSTRACT_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_ABSTRACT_COLLECTION))
#define GEE_IS_ABSTRACT_COLLECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_ABSTRACT_COLLECTION))
#define GEE_ABSTRACT_COLLECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_ABSTRACT_COLLECTION, GeeAbstractCollectionClass))

typedef struct _GeeAbstractCollection GeeAbstractCollection;
typedef struct _GeeAbstractCollectionClass GeeAbstractCollectionClass;

#define GEE_TYPE_ABSTRACT_SET (gee_abstract_set_get_type ())
#define GEE_ABSTRACT_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_ABSTRACT_SET, GeeAbstractSet))
#define GEE_ABSTRACT_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_ABSTRACT_SET, GeeAbstractSetClass))
#define GEE_IS_ABSTRACT_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_ABSTRACT_SET))
#define GEE_IS_ABSTRACT_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_ABSTRACT_SET))
#define GEE_ABSTRACT_SET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_ABSTRACT_SET, GeeAbstractSetClass))

typedef struct _GeeAbstractSet GeeAbstractSet;
typedef struct _GeeAbstractSetClass GeeAbstractSetClass;

#define GEE_HASH_MAP_TYPE_KEY_SET (gee_hash_map_key_set_get_type ())
#define GEE_HASH_MAP_KEY_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_HASH_MAP_TYPE_KEY_SET, GeeHashMapKeySet))
#define GEE_HASH_MAP_KEY_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_HASH_MAP_TYPE_KEY_SET, GeeHashMapKeySetClass))
#define GEE_HASH_MAP_IS_KEY_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_HASH_MAP_TYPE_KEY_SET))
#define GEE_HASH_MAP_IS_KEY_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_HASH_MAP_TYPE_KEY_SET))
#define GEE_HASH_MAP_KEY_SET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_HASH_MAP_TYPE_KEY_SET, GeeHashMapKeySetClass))

typedef struct _GeeHashMapKeySet GeeHashMapKeySet;
typedef struct _GeeHashMapKeySetClass GeeHashMapKeySetClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define GEE_HASH_MAP_TYPE_VALUE_COLLECTION (gee_hash_map_value_collection_get_type ())
#define GEE_HASH_MAP_VALUE_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_HASH_MAP_TYPE_VALUE_COLLECTION, GeeHashMapValueCollection))
#define GEE_HASH_MAP_VALUE_COLLECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_HASH_MAP_TYPE_VALUE_COLLECTION, GeeHashMapValueCollectionClass))
#define GEE_HASH_MAP_IS_VALUE_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_HASH_MAP_TYPE_VALUE_COLLECTION))
#define GEE_HASH_MAP_IS_VALUE_COLLECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_HASH_MAP_TYPE_VALUE_COLLECTION))
#define GEE_HASH_MAP_VALUE_COLLECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_HASH_MAP_TYPE_VALUE_COLLECTION, GeeHashMapValueCollectionClass))

typedef struct _GeeHashMapValueCollection GeeHashMapValueCollection;
typedef struct _GeeHashMapValueCollectionClass GeeHashMapValueCollectionClass;

#define GEE_HASH_MAP_TYPE_ENTRY_SET (gee_hash_map_entry_set_get_type ())
#define GEE_HASH_MAP_ENTRY_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_HASH_MAP_TYPE_ENTRY_SET, GeeHashMapEntrySet))
#define GEE_HASH_MAP_ENTRY_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_HASH_MAP_TYPE_ENTRY_SET, GeeHashMapEntrySetClass))
#define GEE_HASH_MAP_IS_ENTRY_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_HASH_MAP_TYPE_ENTRY_SET))
#define GEE_HASH_MAP_IS_ENTRY_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_HASH_MAP_TYPE_ENTRY_SET))
#define GEE_HASH_MAP_ENTRY_SET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_HASH_MAP_TYPE_ENTRY_SET, GeeHashMapEntrySetClass))

typedef struct _GeeHashMapEntrySet GeeHashMapEntrySet;
typedef struct _GeeHashMapEntrySetClass GeeHashMapEntrySetClass;
typedef struct _GeeMapEntryPrivate GeeMapEntryPrivate;

#define GEE_HASH_MAP_TYPE_ENTRY (gee_hash_map_entry_get_type ())
#define GEE_HASH_MAP_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_HASH_MAP_TYPE_ENTRY, GeeHashMapEntry))
#define GEE_HASH_MAP_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_HASH_MAP_TYPE_ENTRY, GeeHashMapEntryClass))
#define GEE_HASH_MAP_IS_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_HASH_MAP_TYPE_ENTRY))
#define GEE_HASH_MAP_IS_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_HASH_MAP_TYPE_ENTRY))
#define GEE_HASH_MAP_ENTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_HASH_MAP_TYPE_ENTRY, GeeHashMapEntryClass))

typedef struct _GeeHashMapEntry GeeHashMapEntry;
typedef struct _GeeHashMapEntryClass GeeHashMapEntryClass;
typedef struct _GeeHashMapEntryPrivate GeeHashMapEntryPrivate;
typedef struct _GeeAbstractCollectionPrivate GeeAbstractCollectionPrivate;
typedef struct _GeeAbstractSetPrivate GeeAbstractSetPrivate;
typedef struct _GeeHashMapKeySetPrivate GeeHashMapKeySetPrivate;

#define GEE_HASH_MAP_TYPE_KEY_ITERATOR (gee_hash_map_key_iterator_get_type ())
#define GEE_HASH_MAP_KEY_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_HASH_MAP_TYPE_KEY_ITERATOR, GeeHashMapKeyIterator))
#define GEE_HASH_MAP_KEY_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_HASH_MAP_TYPE_KEY_ITERATOR, GeeHashMapKeyIteratorClass))
#define GEE_HASH_MAP_IS_KEY_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_HASH_MAP_TYPE_KEY_ITERATOR))
#define GEE_HASH_MAP_IS_KEY_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_HASH_MAP_TYPE_KEY_ITERATOR))
#define GEE_HASH_MAP_KEY_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_HASH_MAP_TYPE_KEY_ITERATOR, GeeHashMapKeyIteratorClass))

typedef struct _GeeHashMapKeyIterator GeeHashMapKeyIterator;
typedef struct _GeeHashMapKeyIteratorClass GeeHashMapKeyIteratorClass;
typedef struct _GeeHashMapValueCollectionPrivate GeeHashMapValueCollectionPrivate;

#define GEE_HASH_MAP_TYPE_VALUE_ITERATOR (gee_hash_map_value_iterator_get_type ())
#define GEE_HASH_MAP_VALUE_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_HASH_MAP_TYPE_VALUE_ITERATOR, GeeHashMapValueIterator))
#define GEE_HASH_MAP_VALUE_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_HASH_MAP_TYPE_VALUE_ITERATOR, GeeHashMapValueIteratorClass))
#define GEE_HASH_MAP_IS_VALUE_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_HASH_MAP_TYPE_VALUE_ITERATOR))
#define GEE_HASH_MAP_IS_VALUE_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_HASH_MAP_TYPE_VALUE_ITERATOR))
#define GEE_HASH_MAP_VALUE_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_HASH_MAP_TYPE_VALUE_ITERATOR, GeeHashMapValueIteratorClass))

typedef struct _GeeHashMapValueIterator GeeHashMapValueIterator;
typedef struct _GeeHashMapValueIteratorClass GeeHashMapValueIteratorClass;
typedef struct _GeeHashMapEntrySetPrivate GeeHashMapEntrySetPrivate;

#define GEE_HASH_MAP_TYPE_ENTRY_ITERATOR (gee_hash_map_entry_iterator_get_type ())
#define GEE_HASH_MAP_ENTRY_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_HASH_MAP_TYPE_ENTRY_ITERATOR, GeeHashMapEntryIterator))
#define GEE_HASH_MAP_ENTRY_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_HASH_MAP_TYPE_ENTRY_ITERATOR, GeeHashMapEntryIteratorClass))
#define GEE_HASH_MAP_IS_ENTRY_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_HASH_MAP_TYPE_ENTRY_ITERATOR))
#define GEE_HASH_MAP_IS_ENTRY_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_HASH_MAP_TYPE_ENTRY_ITERATOR))
#define GEE_HASH_MAP_ENTRY_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_HASH_MAP_TYPE_ENTRY_ITERATOR, GeeHashMapEntryIteratorClass))

typedef struct _GeeHashMapEntryIterator GeeHashMapEntryIterator;
typedef struct _GeeHashMapEntryIteratorClass GeeHashMapEntryIteratorClass;
typedef struct _GeeHashMapNodeIteratorPrivate GeeHashMapNodeIteratorPrivate;
typedef struct _GeeHashMapKeyIteratorPrivate GeeHashMapKeyIteratorPrivate;
typedef struct _GeeHashMapMapIteratorPrivate GeeHashMapMapIteratorPrivate;
typedef struct _GeeHashMapValueIteratorPrivate GeeHashMapValueIteratorPrivate;
typedef struct _GeeHashMapEntryIteratorPrivate GeeHashMapEntryIteratorPrivate;

struct _GeeIteratorIface {
	GTypeInterface parent_iface;
	gboolean (*next) (GeeIterator* self);
	gboolean (*has_next) (GeeIterator* self);
	gboolean (*first) (GeeIterator* self);
	gpointer (*get) (GeeIterator* self);
	void (*remove) (GeeIterator* self);
};

struct _GeeIterableIface {
	GTypeInterface parent_iface;
	GeeIterator* (*iterator) (GeeIterable* self);
	GType (*get_element_type) (GeeIterable* self);
};

struct _GeeMapIteratorIface {
	GTypeInterface parent_iface;
	gboolean (*next) (GeeMapIterator* self);
	gboolean (*has_next) (GeeMapIterator* self);
	gboolean (*first) (GeeMapIterator* self);
	gpointer (*get_key) (GeeMapIterator* self);
	gpointer (*get_value) (GeeMapIterator* self);
	void (*set_value) (GeeMapIterator* self, gconstpointer value);
	void (*unset) (GeeMapIterator* self);
};

struct _GeeCollectionIface {
	GTypeInterface parent_iface;
	gboolean (*contains) (GeeCollection* self, gconstpointer item);
	gboolean (*add) (GeeCollection* self, gconstpointer item);
	gboolean (*remove) (GeeCollection* self, gconstpointer item);
	void (*clear) (GeeCollection* self);
	gboolean (*add_all) (GeeCollection* self, GeeCollection* collection);
	gboolean (*contains_all) (GeeCollection* self, GeeCollection* collection);
	gboolean (*remove_all) (GeeCollection* self, GeeCollection* collection);
	gboolean (*retain_all) (GeeCollection* self, GeeCollection* collection);
	gpointer* (*to_array) (GeeCollection* self, int* result_length1);
	gint (*get_size) (GeeCollection* self);
	gboolean (*get_is_empty) (GeeCollection* self);
	GeeCollection* (*get_read_only_view) (GeeCollection* self);
};

struct _GeeSetIface {
	GTypeInterface parent_iface;
	GeeSet* (*get_read_only_view) (GeeSet* self);
};

struct _GeeMapIface {
	GTypeInterface parent_iface;
	gboolean (*has_key) (GeeMap* self, gconstpointer key);
	gboolean (*contains) (GeeMap* self, gconstpointer key);
	gboolean (*has) (GeeMap* self, gconstpointer key, gconstpointer value);
	gpointer (*get) (GeeMap* self, gconstpointer key);
	void (*set) (GeeMap* self, gconstpointer key, gconstpointer value);
	gboolean (*unset) (GeeMap* self, gconstpointer key, gpointer* value);
	gboolean (*remove) (GeeMap* self, gconstpointer key, gpointer* value);
	void (*clear) (GeeMap* self);
	GeeMapIterator* (*map_iterator) (GeeMap* self);
	void (*set_all) (GeeMap* self, GeeMap* map);
	gboolean (*unset_all) (GeeMap* self, GeeMap* map);
	gboolean (*remove_all) (GeeMap* self, GeeMap* map);
	gboolean (*has_all) (GeeMap* self, GeeMap* map);
	gboolean (*contains_all) (GeeMap* self, GeeMap* map);
	gint (*get_size) (GeeMap* self);
	gboolean (*get_is_empty) (GeeMap* self);
	GeeSet* (*get_keys) (GeeMap* self);
	GeeCollection* (*get_values) (GeeMap* self);
	GeeSet* (*get_entries) (GeeMap* self);
	GeeMap* (*get_read_only_view) (GeeMap* self);
	GType (*get_key_type) (GeeMap* self);
	GType (*get_value_type) (GeeMap* self);
};

struct _GeeAbstractMap {
	GObject parent_instance;
	GeeAbstractMapPrivate * priv;
};

struct _GeeAbstractMapClass {
	GObjectClass parent_class;
	gboolean (*has_key) (GeeAbstractMap* self, gconstpointer key);
	gboolean (*has) (GeeAbstractMap* self, gconstpointer key, gconstpointer value);
	gpointer (*get) (GeeAbstractMap* self, gconstpointer key);
	void (*set) (GeeAbstractMap* self, gconstpointer key, gconstpointer value);
	gboolean (*unset) (GeeAbstractMap* self, gconstpointer key, gpointer* value);
	GeeMapIterator* (*map_iterator) (GeeAbstractMap* self);
	void (*clear) (GeeAbstractMap* self);
	void (*set_all) (GeeAbstractMap* self, GeeMap* map);
	gboolean (*unset_all) (GeeAbstractMap* self, GeeMap* map);
	gboolean (*has_all) (GeeAbstractMap* self, GeeMap* map);
	gint (*get_size) (GeeAbstractMap* self);
	gboolean (*get_is_empty) (GeeAbstractMap* self);
	GeeSet* (*get_keys) (GeeAbstractMap* self);
	GeeCollection* (*get_values) (GeeAbstractMap* self);
	GeeSet* (*get_entries) (GeeAbstractMap* self);
	GeeMap* (*get_read_only_view) (GeeAbstractMap* self);
};

struct _GeeHashMap {
	GeeAbstractMap parent_instance;
	GeeHashMapPrivate * priv;
};

struct _GeeHashMapClass {
	GeeAbstractMapClass parent_class;
};

struct _GeeHashMapPrivate {
	GType k_type;
	GBoxedCopyFunc k_dup_func;
	GDestroyNotify k_destroy_func;
	GType v_type;
	GBoxedCopyFunc v_dup_func;
	GDestroyNotify v_destroy_func;
	GHashFunc _key_hash_func;
	GEqualFunc _key_equal_func;
	GEqualFunc _value_equal_func;
	gint _array_size;
	gint _nnodes;
	GeeHashMapNode** _nodes;
	gint _nodes_length1;
	gint __nodes_size_;
	GeeSet* _keys;
	GeeCollection* _values;
	GeeSet* _entries;
	gint _stamp;
};

struct _GeeHashMapNode {
	gpointer key;
	gpointer value;
	GeeHashMapNode* next;
	guint key_hash;
	GeeMapEntry* entry;
};

struct _GeeMapEntry {
	GObject parent_instance;
	GeeMapEntryPrivate * priv;
};

struct _GeeMapEntryClass {
	GObjectClass parent_class;
	gconstpointer (*get_key) (GeeMapEntry* self);
	gconstpointer (*get_value) (GeeMapEntry* self);
	void (*set_value) (GeeMapEntry* self, gconstpointer value);
};

struct _GeeHashMapEntry {
	GeeMapEntry parent_instance;
	GeeHashMapEntryPrivate * priv;
};

struct _GeeHashMapEntryClass {
	GeeMapEntryClass parent_class;
};

struct _GeeHashMapEntryPrivate {
	GType k_type;
	GBoxedCopyFunc k_dup_func;
	GDestroyNotify k_destroy_func;
	GType v_type;
	GBoxedCopyFunc v_dup_func;
	GDestroyNotify v_destroy_func;
	GeeHashMapNode* _node;
};

struct _GeeAbstractCollection {
	GObject parent_instance;
	GeeAbstractCollectionPrivate * priv;
};

struct _GeeAbstractCollectionClass {
	GObjectClass parent_class;
	gboolean (*contains) (GeeAbstractCollection* self, gconstpointer item);
	gboolean (*add) (GeeAbstractCollection* self, gconstpointer item);
	gboolean (*remove) (GeeAbstractCollection* self, gconstpointer item);
	void (*clear) (GeeAbstractCollection* self);
	gpointer* (*to_array) (GeeAbstractCollection* self, int* result_length1);
	gboolean (*add_all) (GeeAbstractCollection* self, GeeCollection* collection);
	gboolean (*contains_all) (GeeAbstractCollection* self, GeeCollection* collection);
	gboolean (*remove_all) (GeeAbstractCollection* self, GeeCollection* collection);
	gboolean (*retain_all) (GeeAbstractCollection* self, GeeCollection* collection);
	GeeIterator* (*iterator) (GeeAbstractCollection* self);
	gint (*get_size) (GeeAbstractCollection* self);
	gboolean (*get_is_empty) (GeeAbstractCollection* self);
	GeeCollection* (*get_read_only_view) (GeeAbstractCollection* self);
};

struct _GeeAbstractSet {
	GeeAbstractCollection parent_instance;
	GeeAbstractSetPrivate * priv;
};

struct _GeeAbstractSetClass {
	GeeAbstractCollectionClass parent_class;
	GeeSet* (*get_read_only_view) (GeeAbstractSet* self);
};

struct _GeeHashMapKeySet {
	GeeAbstractSet parent_instance;
	GeeHashMapKeySetPrivate * priv;
};

struct _GeeHashMapKeySetClass {
	GeeAbstractSetClass parent_class;
};

struct _GeeHashMapKeySetPrivate {
	GType k_type;
	GBoxedCopyFunc k_dup_func;
	GDestroyNotify k_destroy_func;
	GType v_type;
	GBoxedCopyFunc v_dup_func;
	GDestroyNotify v_destroy_func;
	GeeHashMap* _map;
};

struct _GeeHashMapValueCollection {
	GeeAbstractCollection parent_instance;
	GeeHashMapValueCollectionPrivate * priv;
};

struct _GeeHashMapValueCollectionClass {
	GeeAbstractCollectionClass parent_class;
};

struct _GeeHashMapValueCollectionPrivate {
	GType k_type;
	GBoxedCopyFunc k_dup_func;
	GDestroyNotify k_destroy_func;
	GType v_type;
	GBoxedCopyFunc v_dup_func;
	GDestroyNotify v_destroy_func;
	GeeHashMap* _map;
};

struct _GeeHashMapEntrySet {
	GeeAbstractSet parent_instance;
	GeeHashMapEntrySetPrivate * priv;
};

struct _GeeHashMapEntrySetClass {
	GeeAbstractSetClass parent_class;
};

struct _GeeHashMapEntrySetPrivate {
	GType k_type;
	GBoxedCopyFunc k_dup_func;
	GDestroyNotify k_destroy_func;
	GType v_type;
	GBoxedCopyFunc v_dup_func;
	GDestroyNotify v_destroy_func;
	GeeHashMap* _map;
};

struct _GeeHashMapNodeIterator {
	GObject parent_instance;
	GeeHashMapNodeIteratorPrivate * priv;
	GeeHashMap* _map;
	GeeHashMapNode* _node;
	GeeHashMapNode* _next;
	gint _stamp;
};

struct _GeeHashMapNodeIteratorClass {
	GObjectClass parent_class;
};

struct _GeeHashMapNodeIteratorPrivate {
	GType k_type;
	GBoxedCopyFunc k_dup_func;
	GDestroyNotify k_destroy_func;
	GType v_type;
	GBoxedCopyFunc v_dup_func;
	GDestroyNotify v_destroy_func;
	gint _index;
};

struct _GeeHashMapKeyIterator {
	GeeHashMapNodeIterator parent_instance;
	GeeHashMapKeyIteratorPrivate * priv;
};

struct _GeeHashMapKeyIteratorClass {
	GeeHashMapNodeIteratorClass parent_class;
};

struct _GeeHashMapKeyIteratorPrivate {
	GType k_type;
	GBoxedCopyFunc k_dup_func;
	GDestroyNotify k_destroy_func;
	GType v_type;
	GBoxedCopyFunc v_dup_func;
	GDestroyNotify v_destroy_func;
};

struct _GeeHashMapMapIterator {
	GeeHashMapNodeIterator parent_instance;
	GeeHashMapMapIteratorPrivate * priv;
};

struct _GeeHashMapMapIteratorClass {
	GeeHashMapNodeIteratorClass parent_class;
};

struct _GeeHashMapMapIteratorPrivate {
	GType k_type;
	GBoxedCopyFunc k_dup_func;
	GDestroyNotify k_destroy_func;
	GType v_type;
	GBoxedCopyFunc v_dup_func;
	GDestroyNotify v_destroy_func;
};

struct _GeeHashMapValueIterator {
	GeeHashMapNodeIterator parent_instance;
	GeeHashMapValueIteratorPrivate * priv;
};

struct _GeeHashMapValueIteratorClass {
	GeeHashMapNodeIteratorClass parent_class;
};

struct _GeeHashMapValueIteratorPrivate {
	GType k_type;
	GBoxedCopyFunc k_dup_func;
	GDestroyNotify k_destroy_func;
	GType v_type;
	GBoxedCopyFunc v_dup_func;
	GDestroyNotify v_destroy_func;
};

struct _GeeHashMapEntryIterator {
	GeeHashMapNodeIterator parent_instance;
	GeeHashMapEntryIteratorPrivate * priv;
};

struct _GeeHashMapEntryIteratorClass {
	GeeHashMapNodeIteratorClass parent_class;
};

struct _GeeHashMapEntryIteratorPrivate {
	GType k_type;
	GBoxedCopyFunc k_dup_func;
	GDestroyNotify k_destroy_func;
	GType v_type;
	GBoxedCopyFunc v_dup_func;
	GDestroyNotify v_destroy_func;
};


static gpointer gee_hash_map_parent_class = NULL;
static gpointer gee_hash_map_entry_parent_class = NULL;
static gpointer gee_hash_map_key_set_parent_class = NULL;
static gpointer gee_hash_map_value_collection_parent_class = NULL;
static gpointer gee_hash_map_entry_set_parent_class = NULL;
static gpointer gee_hash_map_node_iterator_parent_class = NULL;
static gpointer gee_hash_map_key_iterator_parent_class = NULL;
static GeeIteratorIface* gee_hash_map_key_iterator_gee_iterator_parent_iface = NULL;
static gpointer gee_hash_map_map_iterator_parent_class = NULL;
static GeeMapIteratorIface* gee_hash_map_map_iterator_gee_map_iterator_parent_iface = NULL;
static gpointer gee_hash_map_value_iterator_parent_class = NULL;
static GeeIteratorIface* gee_hash_map_value_iterator_gee_iterator_parent_iface = NULL;
static gpointer gee_hash_map_entry_iterator_parent_class = NULL;
static GeeIteratorIface* gee_hash_map_entry_iterator_gee_iterator_parent_iface = NULL;

GType gee_iterator_get_type (void) G_GNUC_CONST;
GType gee_iterable_get_type (void) G_GNUC_CONST;
GType gee_map_iterator_get_type (void) G_GNUC_CONST;
GType gee_collection_get_type (void) G_GNUC_CONST;
GType gee_set_get_type (void) G_GNUC_CONST;
GType gee_map_entry_get_type (void) G_GNUC_CONST;
GType gee_map_get_type (void) G_GNUC_CONST;
GType gee_abstract_map_get_type (void) G_GNUC_CONST;
GType gee_hash_map_get_type (void) G_GNUC_CONST;
static void gee_hash_map_node_free (GeeHashMapNode* self);
#define GEE_HASH_MAP_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEE_TYPE_HASH_MAP, GeeHashMapPrivate))
enum  {
	GEE_HASH_MAP_DUMMY_PROPERTY,
	GEE_HASH_MAP_K_TYPE,
	GEE_HASH_MAP_K_DUP_FUNC,
	GEE_HASH_MAP_K_DESTROY_FUNC,
	GEE_HASH_MAP_V_TYPE,
	GEE_HASH_MAP_V_DUP_FUNC,
	GEE_HASH_MAP_V_DESTROY_FUNC,
	GEE_HASH_MAP_SIZE,
	GEE_HASH_MAP_KEYS,
	GEE_HASH_MAP_VALUES,
	GEE_HASH_MAP_ENTRIES,
	GEE_HASH_MAP_KEY_HASH_FUNC,
	GEE_HASH_MAP_KEY_EQUAL_FUNC,
	GEE_HASH_MAP_VALUE_EQUAL_FUNC
};
void gee_abstract_map_clear (GeeAbstractMap* self);
#define GEE_HASH_MAP_MIN_SIZE 11
#define GEE_HASH_MAP_MAX_SIZE 13845163
GeeHashMap* gee_hash_map_new (GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GHashFunc key_hash_func, GEqualFunc key_equal_func, GEqualFunc value_equal_func);
GeeHashMap* gee_hash_map_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GHashFunc key_hash_func, GEqualFunc key_equal_func, GEqualFunc value_equal_func);
GeeAbstractMap* gee_abstract_map_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func);
GHashFunc gee_functions_get_hash_func_for (GType t);
GEqualFunc gee_functions_get_equal_func_for (GType t);
static void gee_hash_map_set_key_hash_func (GeeHashMap* self, GHashFunc value);
static void gee_hash_map_set_key_equal_func (GeeHashMap* self, GEqualFunc value);
static void gee_hash_map_set_value_equal_func (GeeHashMap* self, GEqualFunc value);
static GeeHashMapNode** gee_hash_map_lookup_node (GeeHashMap* self, gconstpointer key);
GHashFunc gee_hash_map_get_key_hash_func (GeeHashMap* self);
GEqualFunc gee_hash_map_get_key_equal_func (GeeHashMap* self);
static gboolean gee_hash_map_real_has_key (GeeAbstractMap* base, gconstpointer key);
static gboolean gee_hash_map_real_has (GeeAbstractMap* base, gconstpointer key, gconstpointer value);
GEqualFunc gee_hash_map_get_value_equal_func (GeeHashMap* self);
static gpointer gee_hash_map_real_get (GeeAbstractMap* base, gconstpointer key);
static void gee_hash_map_real_set (GeeAbstractMap* base, gconstpointer key, gconstpointer value);
static GeeHashMapNode* gee_hash_map_node_new (gpointer k, gpointer v, guint hash);
static GeeHashMapNode* gee_hash_map_node_new (gpointer k, gpointer v, guint hash);
static void gee_hash_map_resize (GeeHashMap* self);
static gboolean gee_hash_map_real_unset (GeeAbstractMap* base, gconstpointer key, gpointer* value);
static void gee_hash_map_real_clear (GeeAbstractMap* base);
static GeeMapIterator* gee_hash_map_real_map_iterator (GeeAbstractMap* base);
static GeeHashMapMapIterator* gee_hash_map_map_iterator_new (GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map);
static GeeHashMapMapIterator* gee_hash_map_map_iterator_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map);
static GType gee_hash_map_node_iterator_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static GType gee_hash_map_map_iterator_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static GeeHashMapKeySet* gee_hash_map_key_set_new (GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map);
static GeeHashMapKeySet* gee_hash_map_key_set_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map);
GType gee_abstract_collection_get_type (void) G_GNUC_CONST;
GType gee_abstract_set_get_type (void) G_GNUC_CONST;
static GType gee_hash_map_key_set_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static GeeHashMapValueCollection* gee_hash_map_value_collection_new (GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map);
static GeeHashMapValueCollection* gee_hash_map_value_collection_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map);
static GType gee_hash_map_value_collection_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static GeeHashMapEntrySet* gee_hash_map_entry_set_new (GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map);
static GeeHashMapEntrySet* gee_hash_map_entry_set_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map);
static GType gee_hash_map_entry_set_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static void gee_hash_map_node_instance_init (GeeHashMapNode * self);
static GType gee_hash_map_entry_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
#define GEE_HASH_MAP_ENTRY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEE_HASH_MAP_TYPE_ENTRY, GeeHashMapEntryPrivate))
enum  {
	GEE_HASH_MAP_ENTRY_DUMMY_PROPERTY,
	GEE_HASH_MAP_ENTRY_K_TYPE,
	GEE_HASH_MAP_ENTRY_K_DUP_FUNC,
	GEE_HASH_MAP_ENTRY_K_DESTROY_FUNC,
	GEE_HASH_MAP_ENTRY_V_TYPE,
	GEE_HASH_MAP_ENTRY_V_DUP_FUNC,
	GEE_HASH_MAP_ENTRY_V_DESTROY_FUNC,
	GEE_HASH_MAP_ENTRY_KEY,
	GEE_HASH_MAP_ENTRY_VALUE
};
static GeeMapEntry* gee_hash_map_entry_entry_for (GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMapNode* node);
static GeeHashMapEntry* gee_hash_map_entry_new (GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMapNode* node);
static GeeHashMapEntry* gee_hash_map_entry_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMapNode* node);
GeeMapEntry* gee_map_entry_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func);
static void gee_hash_map_entry_finalize (GObject* obj);
gconstpointer gee_map_entry_get_key (GeeMapEntry* self);
gconstpointer gee_map_entry_get_value (GeeMapEntry* self);
static void _vala_gee_hash_map_entry_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
void gee_map_entry_set_value (GeeMapEntry* self, gconstpointer value);
static void _vala_gee_hash_map_entry_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define GEE_HASH_MAP_KEY_SET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEE_HASH_MAP_TYPE_KEY_SET, GeeHashMapKeySetPrivate))
enum  {
	GEE_HASH_MAP_KEY_SET_DUMMY_PROPERTY,
	GEE_HASH_MAP_KEY_SET_K_TYPE,
	GEE_HASH_MAP_KEY_SET_K_DUP_FUNC,
	GEE_HASH_MAP_KEY_SET_K_DESTROY_FUNC,
	GEE_HASH_MAP_KEY_SET_V_TYPE,
	GEE_HASH_MAP_KEY_SET_V_DUP_FUNC,
	GEE_HASH_MAP_KEY_SET_V_DESTROY_FUNC,
	GEE_HASH_MAP_KEY_SET_SIZE
};
GeeAbstractSet* gee_abstract_set_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func);
static GeeIterator* gee_hash_map_key_set_real_iterator (GeeAbstractCollection* base);
static GeeHashMapKeyIterator* gee_hash_map_key_iterator_new (GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map);
static GeeHashMapKeyIterator* gee_hash_map_key_iterator_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map);
static GType gee_hash_map_key_iterator_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static gboolean gee_hash_map_key_set_real_add (GeeAbstractCollection* base, gconstpointer key);
static void gee_hash_map_key_set_real_clear (GeeAbstractCollection* base);
static gboolean gee_hash_map_key_set_real_remove (GeeAbstractCollection* base, gconstpointer key);
static gboolean gee_hash_map_key_set_real_contains (GeeAbstractCollection* base, gconstpointer key);
gboolean gee_abstract_map_has_key (GeeAbstractMap* self, gconstpointer key);
static gboolean gee_hash_map_key_set_real_add_all (GeeAbstractCollection* base, GeeCollection* collection);
static gboolean gee_hash_map_key_set_real_remove_all (GeeAbstractCollection* base, GeeCollection* collection);
static gboolean gee_hash_map_key_set_real_retain_all (GeeAbstractCollection* base, GeeCollection* collection);
gint gee_abstract_map_get_size (GeeAbstractMap* self);
static void gee_hash_map_key_set_finalize (GObject* obj);
gint gee_abstract_collection_get_size (GeeAbstractCollection* self);
static void _vala_gee_hash_map_key_set_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_gee_hash_map_key_set_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define GEE_HASH_MAP_VALUE_COLLECTION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEE_HASH_MAP_TYPE_VALUE_COLLECTION, GeeHashMapValueCollectionPrivate))
enum  {
	GEE_HASH_MAP_VALUE_COLLECTION_DUMMY_PROPERTY,
	GEE_HASH_MAP_VALUE_COLLECTION_K_TYPE,
	GEE_HASH_MAP_VALUE_COLLECTION_K_DUP_FUNC,
	GEE_HASH_MAP_VALUE_COLLECTION_K_DESTROY_FUNC,
	GEE_HASH_MAP_VALUE_COLLECTION_V_TYPE,
	GEE_HASH_MAP_VALUE_COLLECTION_V_DUP_FUNC,
	GEE_HASH_MAP_VALUE_COLLECTION_V_DESTROY_FUNC,
	GEE_HASH_MAP_VALUE_COLLECTION_SIZE
};
GeeAbstractCollection* gee_abstract_collection_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func);
static GeeIterator* gee_hash_map_value_collection_real_iterator (GeeAbstractCollection* base);
static GeeHashMapValueIterator* gee_hash_map_value_iterator_new (GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map);
static GeeHashMapValueIterator* gee_hash_map_value_iterator_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map);
static GType gee_hash_map_value_iterator_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static gboolean gee_hash_map_value_collection_real_add (GeeAbstractCollection* base, gconstpointer value);
static void gee_hash_map_value_collection_real_clear (GeeAbstractCollection* base);
static gboolean gee_hash_map_value_collection_real_remove (GeeAbstractCollection* base, gconstpointer value);
static gboolean gee_hash_map_value_collection_real_contains (GeeAbstractCollection* base, gconstpointer value);
GeeIterator* gee_abstract_collection_iterator (GeeAbstractCollection* self);
gboolean gee_iterator_next (GeeIterator* self);
gpointer gee_iterator_get (GeeIterator* self);
static gboolean gee_hash_map_value_collection_real_add_all (GeeAbstractCollection* base, GeeCollection* collection);
static gboolean gee_hash_map_value_collection_real_remove_all (GeeAbstractCollection* base, GeeCollection* collection);
static gboolean gee_hash_map_value_collection_real_retain_all (GeeAbstractCollection* base, GeeCollection* collection);
static void gee_hash_map_value_collection_finalize (GObject* obj);
static void _vala_gee_hash_map_value_collection_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_gee_hash_map_value_collection_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define GEE_HASH_MAP_ENTRY_SET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEE_HASH_MAP_TYPE_ENTRY_SET, GeeHashMapEntrySetPrivate))
enum  {
	GEE_HASH_MAP_ENTRY_SET_DUMMY_PROPERTY,
	GEE_HASH_MAP_ENTRY_SET_K_TYPE,
	GEE_HASH_MAP_ENTRY_SET_K_DUP_FUNC,
	GEE_HASH_MAP_ENTRY_SET_K_DESTROY_FUNC,
	GEE_HASH_MAP_ENTRY_SET_V_TYPE,
	GEE_HASH_MAP_ENTRY_SET_V_DUP_FUNC,
	GEE_HASH_MAP_ENTRY_SET_V_DESTROY_FUNC,
	GEE_HASH_MAP_ENTRY_SET_SIZE
};
static GeeIterator* gee_hash_map_entry_set_real_iterator (GeeAbstractCollection* base);
static GeeHashMapEntryIterator* gee_hash_map_entry_iterator_new (GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map);
static GeeHashMapEntryIterator* gee_hash_map_entry_iterator_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map);
static GType gee_hash_map_entry_iterator_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static gboolean gee_hash_map_entry_set_real_add (GeeAbstractCollection* base, GeeMapEntry* entry);
static void gee_hash_map_entry_set_real_clear (GeeAbstractCollection* base);
static gboolean gee_hash_map_entry_set_real_remove (GeeAbstractCollection* base, GeeMapEntry* entry);
static gboolean gee_hash_map_entry_set_real_contains (GeeAbstractCollection* base, GeeMapEntry* entry);
gboolean gee_abstract_map_has (GeeAbstractMap* self, gconstpointer key, gconstpointer value);
static gboolean gee_hash_map_entry_set_real_add_all (GeeAbstractCollection* base, GeeCollection* entries);
static gboolean gee_hash_map_entry_set_real_remove_all (GeeAbstractCollection* base, GeeCollection* entries);
static gboolean gee_hash_map_entry_set_real_retain_all (GeeAbstractCollection* base, GeeCollection* entries);
static void gee_hash_map_entry_set_finalize (GObject* obj);
static void _vala_gee_hash_map_entry_set_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_gee_hash_map_entry_set_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define GEE_HASH_MAP_NODE_ITERATOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEE_HASH_MAP_TYPE_NODE_ITERATOR, GeeHashMapNodeIteratorPrivate))
enum  {
	GEE_HASH_MAP_NODE_ITERATOR_DUMMY_PROPERTY,
	GEE_HASH_MAP_NODE_ITERATOR_K_TYPE,
	GEE_HASH_MAP_NODE_ITERATOR_K_DUP_FUNC,
	GEE_HASH_MAP_NODE_ITERATOR_K_DESTROY_FUNC,
	GEE_HASH_MAP_NODE_ITERATOR_V_TYPE,
	GEE_HASH_MAP_NODE_ITERATOR_V_DUP_FUNC,
	GEE_HASH_MAP_NODE_ITERATOR_V_DESTROY_FUNC
};
static GeeHashMapNodeIterator* gee_hash_map_node_iterator_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map);
static gboolean gee_hash_map_node_iterator_next (GeeHashMapNodeIterator* self);
static gboolean gee_hash_map_node_iterator_has_next (GeeHashMapNodeIterator* self);
static gboolean gee_hash_map_node_iterator_first (GeeHashMapNodeIterator* self);
static void gee_hash_map_node_iterator_finalize (GObject* obj);
static void _vala_gee_hash_map_node_iterator_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_gee_hash_map_node_iterator_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define GEE_HASH_MAP_KEY_ITERATOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEE_HASH_MAP_TYPE_KEY_ITERATOR, GeeHashMapKeyIteratorPrivate))
enum  {
	GEE_HASH_MAP_KEY_ITERATOR_DUMMY_PROPERTY,
	GEE_HASH_MAP_KEY_ITERATOR_K_TYPE,
	GEE_HASH_MAP_KEY_ITERATOR_K_DUP_FUNC,
	GEE_HASH_MAP_KEY_ITERATOR_K_DESTROY_FUNC,
	GEE_HASH_MAP_KEY_ITERATOR_V_TYPE,
	GEE_HASH_MAP_KEY_ITERATOR_V_DUP_FUNC,
	GEE_HASH_MAP_KEY_ITERATOR_V_DESTROY_FUNC
};
static gpointer gee_hash_map_key_iterator_real_get (GeeIterator* base);
static void gee_hash_map_key_iterator_real_remove (GeeIterator* base);
static void _vala_gee_hash_map_key_iterator_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_gee_hash_map_key_iterator_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define GEE_HASH_MAP_MAP_ITERATOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEE_HASH_MAP_TYPE_MAP_ITERATOR, GeeHashMapMapIteratorPrivate))
enum  {
	GEE_HASH_MAP_MAP_ITERATOR_DUMMY_PROPERTY,
	GEE_HASH_MAP_MAP_ITERATOR_K_TYPE,
	GEE_HASH_MAP_MAP_ITERATOR_K_DUP_FUNC,
	GEE_HASH_MAP_MAP_ITERATOR_K_DESTROY_FUNC,
	GEE_HASH_MAP_MAP_ITERATOR_V_TYPE,
	GEE_HASH_MAP_MAP_ITERATOR_V_DUP_FUNC,
	GEE_HASH_MAP_MAP_ITERATOR_V_DESTROY_FUNC
};
static gpointer gee_hash_map_map_iterator_real_get_key (GeeMapIterator* base);
static void gee_hash_map_map_iterator_real_unset (GeeMapIterator* base);
gboolean gee_map_iterator_has_next (GeeMapIterator* self);
gboolean gee_abstract_map_unset (GeeAbstractMap* self, gconstpointer key, gpointer* value);
static gpointer gee_hash_map_map_iterator_real_get_value (GeeMapIterator* base);
static void gee_hash_map_map_iterator_real_set_value (GeeMapIterator* base, gconstpointer value);
void gee_abstract_map_set (GeeAbstractMap* self, gconstpointer key, gconstpointer value);
static void _vala_gee_hash_map_map_iterator_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_gee_hash_map_map_iterator_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define GEE_HASH_MAP_VALUE_ITERATOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEE_HASH_MAP_TYPE_VALUE_ITERATOR, GeeHashMapValueIteratorPrivate))
enum  {
	GEE_HASH_MAP_VALUE_ITERATOR_DUMMY_PROPERTY,
	GEE_HASH_MAP_VALUE_ITERATOR_K_TYPE,
	GEE_HASH_MAP_VALUE_ITERATOR_K_DUP_FUNC,
	GEE_HASH_MAP_VALUE_ITERATOR_K_DESTROY_FUNC,
	GEE_HASH_MAP_VALUE_ITERATOR_V_TYPE,
	GEE_HASH_MAP_VALUE_ITERATOR_V_DUP_FUNC,
	GEE_HASH_MAP_VALUE_ITERATOR_V_DESTROY_FUNC
};
static gpointer gee_hash_map_value_iterator_real_get (GeeIterator* base);
static void gee_hash_map_value_iterator_real_remove (GeeIterator* base);
static void _vala_gee_hash_map_value_iterator_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_gee_hash_map_value_iterator_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define GEE_HASH_MAP_ENTRY_ITERATOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEE_HASH_MAP_TYPE_ENTRY_ITERATOR, GeeHashMapEntryIteratorPrivate))
enum  {
	GEE_HASH_MAP_ENTRY_ITERATOR_DUMMY_PROPERTY,
	GEE_HASH_MAP_ENTRY_ITERATOR_K_TYPE,
	GEE_HASH_MAP_ENTRY_ITERATOR_K_DUP_FUNC,
	GEE_HASH_MAP_ENTRY_ITERATOR_K_DESTROY_FUNC,
	GEE_HASH_MAP_ENTRY_ITERATOR_V_TYPE,
	GEE_HASH_MAP_ENTRY_ITERATOR_V_DUP_FUNC,
	GEE_HASH_MAP_ENTRY_ITERATOR_V_DESTROY_FUNC
};
static GeeMapEntry* gee_hash_map_entry_iterator_real_get (GeeIterator* base);
static void gee_hash_map_entry_iterator_real_remove (GeeIterator* base);
static void _vala_gee_hash_map_entry_iterator_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_gee_hash_map_entry_iterator_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void gee_hash_map_finalize (GObject* obj);
GeeSet* gee_abstract_map_get_keys (GeeAbstractMap* self);
GeeCollection* gee_abstract_map_get_values (GeeAbstractMap* self);
GeeSet* gee_abstract_map_get_entries (GeeAbstractMap* self);
static void _vala_gee_hash_map_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_gee_hash_map_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


/**
 * Constructs a new, empty hash map.
 *
 * If not provided, the functions parameters are requested to the
 * {@link Functions} function factory methods.
 *
 * @param key_hash_func an optional key hash function
 * @param key_equal_func an optional key equality testing function
 * @param value_equal_func an optional value equality testing function
 */
GeeHashMap* gee_hash_map_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GHashFunc key_hash_func, GEqualFunc key_equal_func, GEqualFunc value_equal_func) {
	GeeHashMap * self = NULL;
	GHashFunc _tmp0_;
	GEqualFunc _tmp2_;
	GEqualFunc _tmp4_;
	GHashFunc _tmp6_;
	GEqualFunc _tmp7_;
	GEqualFunc _tmp8_;
	gint _tmp9_;
	GeeHashMapNode** _tmp10_ = NULL;
	self = (GeeHashMap*) gee_abstract_map_construct (object_type, k_type, (GBoxedCopyFunc) k_dup_func, k_destroy_func, v_type, (GBoxedCopyFunc) v_dup_func, v_destroy_func);
	self->priv->k_type = k_type;
	self->priv->k_dup_func = k_dup_func;
	self->priv->k_destroy_func = k_destroy_func;
	self->priv->v_type = v_type;
	self->priv->v_dup_func = v_dup_func;
	self->priv->v_destroy_func = v_destroy_func;
	_tmp0_ = key_hash_func;
	if (_tmp0_ == NULL) {
		GHashFunc _tmp1_ = NULL;
		_tmp1_ = gee_functions_get_hash_func_for (k_type);
		key_hash_func = _tmp1_;
	}
	_tmp2_ = key_equal_func;
	if (_tmp2_ == NULL) {
		GEqualFunc _tmp3_ = NULL;
		_tmp3_ = gee_functions_get_equal_func_for (k_type);
		key_equal_func = _tmp3_;
	}
	_tmp4_ = value_equal_func;
	if (_tmp4_ == NULL) {
		GEqualFunc _tmp5_ = NULL;
		_tmp5_ = gee_functions_get_equal_func_for (v_type);
		value_equal_func = _tmp5_;
	}
	_tmp6_ = key_hash_func;
	gee_hash_map_set_key_hash_func (self, _tmp6_);
	_tmp7_ = key_equal_func;
	gee_hash_map_set_key_equal_func (self, _tmp7_);
	_tmp8_ = value_equal_func;
	gee_hash_map_set_value_equal_func (self, _tmp8_);
	self->priv->_array_size = GEE_HASH_MAP_MIN_SIZE;
	_tmp9_ = self->priv->_array_size;
	_tmp10_ = g_new0 (GeeHashMapNode*, _tmp9_ + 1);
	self->priv->_nodes = (_vala_array_free (self->priv->_nodes, self->priv->_nodes_length1, (GDestroyNotify) gee_hash_map_node_free), NULL);
	self->priv->_nodes = _tmp10_;
	self->priv->_nodes_length1 = _tmp9_;
	self->priv->__nodes_size_ = self->priv->_nodes_length1;
	return self;
}


GeeHashMap* gee_hash_map_new (GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GHashFunc key_hash_func, GEqualFunc key_equal_func, GEqualFunc value_equal_func) {
	return gee_hash_map_construct (GEE_TYPE_HASH_MAP, k_type, k_dup_func, k_destroy_func, v_type, v_dup_func, v_destroy_func, key_hash_func, key_equal_func, value_equal_func);
}


static GeeHashMapNode** gee_hash_map_lookup_node (GeeHashMap* self, gconstpointer key) {
	GeeHashMapNode** result = NULL;
	GHashFunc _tmp0_;
	GHashFunc _tmp1_;
	gconstpointer _tmp2_;
	guint _tmp3_ = 0U;
	guint hash_value;
	GeeHashMapNode** _tmp4_;
	gint _tmp4__length1;
	guint _tmp5_;
	gint _tmp6_;
	GeeHashMapNode** node;
	GeeHashMapNode** _tmp22_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = gee_hash_map_get_key_hash_func (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = key;
	_tmp3_ = _tmp1_ (_tmp2_);
	hash_value = _tmp3_;
	_tmp4_ = self->priv->_nodes;
	_tmp4__length1 = self->priv->_nodes_length1;
	_tmp5_ = hash_value;
	_tmp6_ = self->priv->_array_size;
	node = &_tmp4_[_tmp5_ % _tmp6_];
	while (TRUE) {
		gboolean _tmp7_ = FALSE;
		GeeHashMapNode** _tmp8_;
		gboolean _tmp20_;
		GeeHashMapNode** _tmp21_;
		_tmp8_ = node;
		if ((*_tmp8_) != NULL) {
			gboolean _tmp9_ = FALSE;
			guint _tmp10_;
			GeeHashMapNode** _tmp11_;
			guint _tmp12_;
			gboolean _tmp19_;
			_tmp10_ = hash_value;
			_tmp11_ = node;
			_tmp12_ = (*_tmp11_)->key_hash;
			if (_tmp10_ != _tmp12_) {
				_tmp9_ = TRUE;
			} else {
				GEqualFunc _tmp13_;
				GEqualFunc _tmp14_;
				GeeHashMapNode** _tmp15_;
				gconstpointer _tmp16_;
				gconstpointer _tmp17_;
				gboolean _tmp18_ = FALSE;
				_tmp13_ = gee_hash_map_get_key_equal_func (self);
				_tmp14_ = _tmp13_;
				_tmp15_ = node;
				_tmp16_ = (*_tmp15_)->key;
				_tmp17_ = key;
				_tmp18_ = _tmp14_ (_tmp16_, _tmp17_);
				_tmp9_ = !_tmp18_;
			}
			_tmp19_ = _tmp9_;
			_tmp7_ = _tmp19_;
		} else {
			_tmp7_ = FALSE;
		}
		_tmp20_ = _tmp7_;
		if (!_tmp20_) {
			break;
		}
		_tmp21_ = node;
		node = &(*_tmp21_)->next;
	}
	_tmp22_ = node;
	result = _tmp22_;
	return result;
}


/**
 * {@inheritDoc}
 */
static gboolean gee_hash_map_real_has_key (GeeAbstractMap* base, gconstpointer key) {
	GeeHashMap * self;
	gboolean result = FALSE;
	gconstpointer _tmp0_;
	GeeHashMapNode** _tmp1_ = NULL;
	GeeHashMapNode** node;
	self = (GeeHashMap*) base;
	_tmp0_ = key;
	_tmp1_ = gee_hash_map_lookup_node (self, _tmp0_);
	node = _tmp1_;
	result = (*node) != NULL;
	return result;
}


/**
 * {@inheritDoc}
 */
static gboolean gee_hash_map_real_has (GeeAbstractMap* base, gconstpointer key, gconstpointer value) {
	GeeHashMap * self;
	gboolean result = FALSE;
	gconstpointer _tmp0_;
	GeeHashMapNode** _tmp1_ = NULL;
	GeeHashMapNode** node;
	gboolean _tmp2_ = FALSE;
	GeeHashMapNode** _tmp3_;
	gboolean _tmp10_;
	self = (GeeHashMap*) base;
	_tmp0_ = key;
	_tmp1_ = gee_hash_map_lookup_node (self, _tmp0_);
	node = _tmp1_;
	_tmp3_ = node;
	if ((*_tmp3_) != NULL) {
		GEqualFunc _tmp4_;
		GEqualFunc _tmp5_;
		GeeHashMapNode** _tmp6_;
		gconstpointer _tmp7_;
		gconstpointer _tmp8_;
		gboolean _tmp9_ = FALSE;
		_tmp4_ = gee_hash_map_get_value_equal_func (self);
		_tmp5_ = _tmp4_;
		_tmp6_ = node;
		_tmp7_ = (*_tmp6_)->value;
		_tmp8_ = value;
		_tmp9_ = _tmp5_ (_tmp7_, _tmp8_);
		_tmp2_ = _tmp9_;
	} else {
		_tmp2_ = FALSE;
	}
	_tmp10_ = _tmp2_;
	result = _tmp10_;
	return result;
}


/**
 * {@inheritDoc}
 */
static gpointer gee_hash_map_real_get (GeeAbstractMap* base, gconstpointer key) {
	GeeHashMap * self;
	gpointer result = NULL;
	gconstpointer _tmp0_;
	GeeHashMapNode** _tmp1_ = NULL;
	GeeHashMapNode* node;
	GeeHashMapNode* _tmp2_;
	self = (GeeHashMap*) base;
	_tmp0_ = key;
	_tmp1_ = gee_hash_map_lookup_node (self, _tmp0_);
	node = *_tmp1_;
	_tmp2_ = node;
	if (_tmp2_ != NULL) {
		GeeHashMapNode* _tmp3_;
		gconstpointer _tmp4_;
		gpointer _tmp5_;
		_tmp3_ = node;
		_tmp4_ = _tmp3_->value;
		_tmp5_ = ((_tmp4_ != NULL) && (self->priv->v_dup_func != NULL)) ? self->priv->v_dup_func ((gpointer) _tmp4_) : ((gpointer) _tmp4_);
		result = _tmp5_;
		return result;
	} else {
		result = NULL;
		return result;
	}
}


/**
 * {@inheritDoc}
 */
static void gee_hash_map_real_set (GeeAbstractMap* base, gconstpointer key, gconstpointer value) {
	GeeHashMap * self;
	gconstpointer _tmp0_;
	GeeHashMapNode** _tmp1_ = NULL;
	GeeHashMapNode** node;
	GeeHashMapNode** _tmp2_;
	gint _tmp19_;
	self = (GeeHashMap*) base;
	_tmp0_ = key;
	_tmp1_ = gee_hash_map_lookup_node (self, _tmp0_);
	node = _tmp1_;
	_tmp2_ = node;
	if ((*_tmp2_) != NULL) {
		GeeHashMapNode** _tmp3_;
		gconstpointer _tmp4_;
		gpointer _tmp5_;
		_tmp3_ = node;
		_tmp4_ = value;
		_tmp5_ = ((_tmp4_ != NULL) && (self->priv->v_dup_func != NULL)) ? self->priv->v_dup_func ((gpointer) _tmp4_) : ((gpointer) _tmp4_);
		(((*_tmp3_)->value == NULL) || (self->priv->v_destroy_func == NULL)) ? NULL : ((*_tmp3_)->value = (self->priv->v_destroy_func ((*_tmp3_)->value), NULL));
		(*_tmp3_)->value = _tmp5_;
	} else {
		GHashFunc _tmp6_;
		GHashFunc _tmp7_;
		gconstpointer _tmp8_;
		guint _tmp9_ = 0U;
		guint hash_value;
		GeeHashMapNode** _tmp10_;
		gconstpointer _tmp11_;
		gpointer _tmp12_;
		gconstpointer _tmp13_;
		gpointer _tmp14_;
		guint _tmp15_;
		GeeHashMapNode* _tmp16_;
		GeeHashMapNode* _tmp17_;
		gint _tmp18_;
		_tmp6_ = gee_hash_map_get_key_hash_func (self);
		_tmp7_ = _tmp6_;
		_tmp8_ = key;
		_tmp9_ = _tmp7_ (_tmp8_);
		hash_value = _tmp9_;
		_tmp10_ = node;
		_tmp11_ = key;
		_tmp12_ = ((_tmp11_ != NULL) && (self->priv->k_dup_func != NULL)) ? self->priv->k_dup_func ((gpointer) _tmp11_) : ((gpointer) _tmp11_);
		_tmp13_ = value;
		_tmp14_ = ((_tmp13_ != NULL) && (self->priv->v_dup_func != NULL)) ? self->priv->v_dup_func ((gpointer) _tmp13_) : ((gpointer) _tmp13_);
		_tmp15_ = hash_value;
		_tmp16_ = gee_hash_map_node_new (_tmp12_, _tmp14_, _tmp15_);
		*_tmp10_ = _tmp16_;
		_tmp17_ = *_tmp10_;
		_tmp18_ = self->priv->_nnodes;
		self->priv->_nnodes = _tmp18_ + 1;
		gee_hash_map_resize (self);
	}
	_tmp19_ = self->priv->_stamp;
	self->priv->_stamp = _tmp19_ + 1;
}


/**
 * {@inheritDoc}
 */
static gboolean gee_hash_map_real_unset (GeeAbstractMap* base, gconstpointer key, gpointer* value) {
	GeeHashMap * self;
	gpointer _vala_value = NULL;
	gboolean result = FALSE;
	gconstpointer _tmp0_;
	GeeHashMapNode** _tmp1_ = NULL;
	GeeHashMapNode** node;
	GeeHashMapNode** _tmp2_;
	self = (GeeHashMap*) base;
	_tmp0_ = key;
	_tmp1_ = gee_hash_map_lookup_node (self, _tmp0_);
	node = _tmp1_;
	_tmp2_ = node;
	if ((*_tmp2_) != NULL) {
		GeeHashMapNode** _tmp3_;
		GeeHashMapNode* _tmp4_;
		GeeHashMapNode* next;
		GeeHashMapNode** _tmp7_;
		GeeHashMapNode** _tmp8_;
		GeeHashMapNode** _tmp9_;
		GeeHashMapNode** _tmp10_;
		GeeHashMapNode* _tmp11_;
		GeeHashMapNode* _tmp12_;
		gint _tmp13_;
		gint _tmp14_;
		_tmp3_ = node;
		_tmp4_ = (*_tmp3_)->next;
		(*_tmp3_)->next = NULL;
		next = _tmp4_;
		if ((&_vala_value) != NULL) {
			GeeHashMapNode** _tmp5_;
			gpointer _tmp6_;
			_tmp5_ = node;
			_tmp6_ = (*_tmp5_)->value;
			(*_tmp5_)->value = NULL;
			((_vala_value == NULL) || (self->priv->v_destroy_func == NULL)) ? NULL : (_vala_value = (self->priv->v_destroy_func (_vala_value), NULL));
			_vala_value = _tmp6_;
		}
		_tmp7_ = node;
		(((*_tmp7_)->key == NULL) || (self->priv->k_destroy_func == NULL)) ? NULL : ((*_tmp7_)->key = (self->priv->k_destroy_func ((*_tmp7_)->key), NULL));
		(*_tmp7_)->key = NULL;
		_tmp8_ = node;
		(((*_tmp8_)->value == NULL) || (self->priv->v_destroy_func == NULL)) ? NULL : ((*_tmp8_)->value = (self->priv->v_destroy_func ((*_tmp8_)->value), NULL));
		(*_tmp8_)->value = NULL;
		_tmp9_ = node;
		gee_hash_map_node_free (*_tmp9_);
		_tmp10_ = node;
		_tmp11_ = next;
		next = NULL;
		*_tmp10_ = _tmp11_;
		_tmp12_ = *_tmp10_;
		_tmp13_ = self->priv->_nnodes;
		self->priv->_nnodes = _tmp13_ - 1;
		gee_hash_map_resize (self);
		_tmp14_ = self->priv->_stamp;
		self->priv->_stamp = _tmp14_ + 1;
		result = TRUE;
		_gee_hash_map_node_free0 (next);
		if (value) {
			*value = _vala_value;
		} else {
			((_vala_value == NULL) || (self->priv->v_destroy_func == NULL)) ? NULL : (_vala_value = (self->priv->v_destroy_func (_vala_value), NULL));
		}
		return result;
	}
	result = FALSE;
	if (value) {
		*value = _vala_value;
	} else {
		((_vala_value == NULL) || (self->priv->v_destroy_func == NULL)) ? NULL : (_vala_value = (self->priv->v_destroy_func (_vala_value), NULL));
	}
	return result;
}


/**
 * {@inheritDoc}
 */
static void gee_hash_map_real_clear (GeeAbstractMap* base) {
	GeeHashMap * self;
	self = (GeeHashMap*) base;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gboolean _tmp1_;
				gint _tmp3_;
				gint _tmp4_;
				GeeHashMapNode** _tmp5_;
				gint _tmp5__length1;
				gint _tmp6_;
				GeeHashMapNode* _tmp7_;
				GeeHashMapNode* node;
				_tmp1_ = _tmp0_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp3_ = i;
				_tmp4_ = self->priv->_array_size;
				if (!(_tmp3_ < _tmp4_)) {
					break;
				}
				_tmp5_ = self->priv->_nodes;
				_tmp5__length1 = self->priv->_nodes_length1;
				_tmp6_ = i;
				_tmp7_ = _tmp5_[_tmp6_];
				_tmp5_[_tmp6_] = NULL;
				node = _tmp7_;
				while (TRUE) {
					GeeHashMapNode* _tmp8_;
					GeeHashMapNode* _tmp9_;
					GeeHashMapNode* _tmp10_;
					GeeHashMapNode* next;
					GeeHashMapNode* _tmp11_;
					GeeHashMapNode* _tmp12_;
					GeeHashMapNode* _tmp13_;
					_tmp8_ = node;
					if (!(_tmp8_ != NULL)) {
						break;
					}
					_tmp9_ = node;
					_tmp10_ = _tmp9_->next;
					_tmp9_->next = NULL;
					next = _tmp10_;
					_tmp11_ = node;
					((_tmp11_->key == NULL) || (self->priv->k_destroy_func == NULL)) ? NULL : (_tmp11_->key = (self->priv->k_destroy_func (_tmp11_->key), NULL));
					_tmp11_->key = NULL;
					_tmp12_ = node;
					((_tmp12_->value == NULL) || (self->priv->v_destroy_func == NULL)) ? NULL : (_tmp12_->value = (self->priv->v_destroy_func (_tmp12_->value), NULL));
					_tmp12_->value = NULL;
					_tmp13_ = next;
					next = NULL;
					_gee_hash_map_node_free0 (node);
					node = _tmp13_;
					_gee_hash_map_node_free0 (next);
				}
				_gee_hash_map_node_free0 (node);
			}
		}
	}
	self->priv->_nnodes = 0;
	gee_hash_map_resize (self);
}


/**
 * {@inheritDoc}
 */
static GeeMapIterator* gee_hash_map_real_map_iterator (GeeAbstractMap* base) {
	GeeHashMap * self;
	GeeMapIterator* result = NULL;
	GeeHashMapMapIterator* _tmp0_;
	self = (GeeHashMap*) base;
	_tmp0_ = gee_hash_map_map_iterator_new (self->priv->k_type, (GBoxedCopyFunc) self->priv->k_dup_func, self->priv->k_destroy_func, self->priv->v_type, (GBoxedCopyFunc) self->priv->v_dup_func, self->priv->v_destroy_func, self);
	result = (GeeMapIterator*) _tmp0_;
	return result;
}


static void gee_hash_map_resize (GeeHashMap* self) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gint _tmp2_;
	gint _tmp3_;
	gboolean _tmp5_;
	gboolean _tmp11_;
	g_return_if_fail (self != NULL);
	_tmp2_ = self->priv->_array_size;
	_tmp3_ = self->priv->_nnodes;
	if (_tmp2_ >= (3 * _tmp3_)) {
		gint _tmp4_;
		_tmp4_ = self->priv->_array_size;
		_tmp1_ = _tmp4_ >= GEE_HASH_MAP_MIN_SIZE;
	} else {
		_tmp1_ = FALSE;
	}
	_tmp5_ = _tmp1_;
	if (_tmp5_) {
		_tmp0_ = TRUE;
	} else {
		gboolean _tmp6_ = FALSE;
		gint _tmp7_;
		gint _tmp8_;
		gboolean _tmp10_;
		_tmp7_ = self->priv->_array_size;
		_tmp8_ = self->priv->_nnodes;
		if ((3 * _tmp7_) <= _tmp8_) {
			gint _tmp9_;
			_tmp9_ = self->priv->_array_size;
			_tmp6_ = _tmp9_ < GEE_HASH_MAP_MAX_SIZE;
		} else {
			_tmp6_ = FALSE;
		}
		_tmp10_ = _tmp6_;
		_tmp0_ = _tmp10_;
	}
	_tmp11_ = _tmp0_;
	if (_tmp11_) {
		gint _tmp12_;
		guint _tmp13_ = 0U;
		gint new_array_size;
		gint _tmp14_;
		gint _tmp15_ = 0;
		gint _tmp16_;
		GeeHashMapNode** _tmp17_ = NULL;
		GeeHashMapNode** new_nodes;
		gint new_nodes_length1;
		gint _new_nodes_size_;
		GeeHashMapNode** _tmp43_;
		gint _tmp43__length1;
		gint _tmp44_;
		_tmp12_ = self->priv->_nnodes;
		_tmp13_ = g_spaced_primes_closest ((guint) _tmp12_);
		new_array_size = (gint) _tmp13_;
		_tmp14_ = new_array_size;
		_tmp15_ = CLAMP (_tmp14_, GEE_HASH_MAP_MIN_SIZE, GEE_HASH_MAP_MAX_SIZE);
		new_array_size = _tmp15_;
		_tmp16_ = new_array_size;
		_tmp17_ = g_new0 (GeeHashMapNode*, _tmp16_ + 1);
		new_nodes = _tmp17_;
		new_nodes_length1 = _tmp16_;
		_new_nodes_size_ = new_nodes_length1;
		{
			gint i;
			i = 0;
			{
				gboolean _tmp18_;
				_tmp18_ = TRUE;
				while (TRUE) {
					gboolean _tmp19_;
					gint _tmp21_;
					gint _tmp22_;
					GeeHashMapNode* node = NULL;
					GeeHashMapNode* next;
					_tmp19_ = _tmp18_;
					if (!_tmp19_) {
						gint _tmp20_;
						_tmp20_ = i;
						i = _tmp20_ + 1;
					}
					_tmp18_ = FALSE;
					_tmp21_ = i;
					_tmp22_ = self->priv->_array_size;
					if (!(_tmp21_ < _tmp22_)) {
						break;
					}
					next = NULL;
					{
						GeeHashMapNode** _tmp23_;
						gint _tmp23__length1;
						gint _tmp24_;
						GeeHashMapNode* _tmp25_;
						gboolean _tmp26_;
						_tmp23_ = self->priv->_nodes;
						_tmp23__length1 = self->priv->_nodes_length1;
						_tmp24_ = i;
						_tmp25_ = _tmp23_[_tmp24_];
						_tmp23_[_tmp24_] = NULL;
						_gee_hash_map_node_free0 (node);
						node = _tmp25_;
						_tmp26_ = TRUE;
						while (TRUE) {
							gboolean _tmp27_;
							GeeHashMapNode* _tmp29_;
							GeeHashMapNode* _tmp30_;
							GeeHashMapNode* _tmp31_;
							GeeHashMapNode* _tmp32_;
							guint _tmp33_;
							gint _tmp34_;
							guint hash_val;
							GeeHashMapNode* _tmp35_;
							GeeHashMapNode** _tmp36_;
							gint _tmp36__length1;
							guint _tmp37_;
							GeeHashMapNode* _tmp38_;
							GeeHashMapNode** _tmp39_;
							gint _tmp39__length1;
							guint _tmp40_;
							GeeHashMapNode* _tmp41_;
							GeeHashMapNode* _tmp42_;
							_tmp27_ = _tmp26_;
							if (!_tmp27_) {
								GeeHashMapNode* _tmp28_;
								_tmp28_ = next;
								next = NULL;
								_gee_hash_map_node_free0 (node);
								node = _tmp28_;
							}
							_tmp26_ = FALSE;
							_tmp29_ = node;
							if (!(_tmp29_ != NULL)) {
								break;
							}
							_tmp30_ = node;
							_tmp31_ = _tmp30_->next;
							_tmp30_->next = NULL;
							_gee_hash_map_node_free0 (next);
							next = _tmp31_;
							_tmp32_ = node;
							_tmp33_ = _tmp32_->key_hash;
							_tmp34_ = new_array_size;
							hash_val = _tmp33_ % _tmp34_;
							_tmp35_ = node;
							_tmp36_ = new_nodes;
							_tmp36__length1 = new_nodes_length1;
							_tmp37_ = hash_val;
							_tmp38_ = _tmp36_[_tmp37_];
							_tmp36_[_tmp37_] = NULL;
							_gee_hash_map_node_free0 (_tmp35_->next);
							_tmp35_->next = _tmp38_;
							_tmp39_ = new_nodes;
							_tmp39__length1 = new_nodes_length1;
							_tmp40_ = hash_val;
							_tmp41_ = node;
							node = NULL;
							_gee_hash_map_node_free0 (_tmp39_[_tmp40_]);
							_tmp39_[_tmp40_] = _tmp41_;
							_tmp42_ = _tmp39_[_tmp40_];
						}
					}
					_gee_hash_map_node_free0 (next);
					_gee_hash_map_node_free0 (node);
				}
			}
		}
		_tmp43_ = new_nodes;
		_tmp43__length1 = new_nodes_length1;
		new_nodes = NULL;
		self->priv->_nodes = (_vala_array_free (self->priv->_nodes, self->priv->_nodes_length1, (GDestroyNotify) gee_hash_map_node_free), NULL);
		self->priv->_nodes = _tmp43_;
		self->priv->_nodes_length1 = _tmp43__length1;
		self->priv->__nodes_size_ = self->priv->_nodes_length1;
		_tmp44_ = new_array_size;
		self->priv->_array_size = _tmp44_;
		new_nodes = (_vala_array_free (new_nodes, new_nodes_length1, (GDestroyNotify) gee_hash_map_node_free), NULL);
	}
}


static gint gee_hash_map_real_get_size (GeeAbstractMap* base) {
	gint result;
	GeeHashMap* self;
	gint _tmp0_;
	self = (GeeHashMap*) base;
	_tmp0_ = self->priv->_nnodes;
	result = _tmp0_;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static GeeSet* gee_hash_map_real_get_keys (GeeAbstractMap* base) {
	GeeSet* result;
	GeeHashMap* self;
	GeeSet* _tmp0_;
	GeeSet* _tmp1_;
	GeeSet* keys;
	GeeSet* _tmp2_;
	self = (GeeHashMap*) base;
	_tmp0_ = self->priv->_keys;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	keys = _tmp1_;
	_tmp2_ = self->priv->_keys;
	if (_tmp2_ == NULL) {
		GeeHashMapKeySet* _tmp3_;
		GeeSet* _tmp4_;
		GeeSet* _tmp5_;
		_tmp3_ = gee_hash_map_key_set_new (self->priv->k_type, (GBoxedCopyFunc) self->priv->k_dup_func, self->priv->k_destroy_func, self->priv->v_type, (GBoxedCopyFunc) self->priv->v_dup_func, self->priv->v_destroy_func, self);
		_g_object_unref0 (keys);
		keys = (GeeSet*) _tmp3_;
		_tmp4_ = keys;
		self->priv->_keys = _tmp4_;
		_tmp5_ = keys;
		g_object_add_weak_pointer ((GObject*) _tmp5_, (void**) (&self->priv->_keys));
	}
	result = keys;
	return result;
}


static GeeCollection* gee_hash_map_real_get_values (GeeAbstractMap* base) {
	GeeCollection* result;
	GeeHashMap* self;
	GeeCollection* _tmp0_;
	GeeCollection* _tmp1_;
	GeeCollection* values;
	GeeCollection* _tmp2_;
	self = (GeeHashMap*) base;
	_tmp0_ = self->priv->_values;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	values = _tmp1_;
	_tmp2_ = self->priv->_values;
	if (_tmp2_ == NULL) {
		GeeHashMapValueCollection* _tmp3_;
		GeeCollection* _tmp4_;
		GeeCollection* _tmp5_;
		_tmp3_ = gee_hash_map_value_collection_new (self->priv->k_type, (GBoxedCopyFunc) self->priv->k_dup_func, self->priv->k_destroy_func, self->priv->v_type, (GBoxedCopyFunc) self->priv->v_dup_func, self->priv->v_destroy_func, self);
		_g_object_unref0 (values);
		values = (GeeCollection*) _tmp3_;
		_tmp4_ = values;
		self->priv->_values = _tmp4_;
		_tmp5_ = values;
		g_object_add_weak_pointer ((GObject*) _tmp5_, (void**) (&self->priv->_values));
	}
	result = values;
	return result;
}


static GeeSet* gee_hash_map_real_get_entries (GeeAbstractMap* base) {
	GeeSet* result;
	GeeHashMap* self;
	GeeSet* _tmp0_;
	GeeSet* _tmp1_;
	GeeSet* entries;
	GeeSet* _tmp2_;
	self = (GeeHashMap*) base;
	_tmp0_ = self->priv->_entries;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	entries = _tmp1_;
	_tmp2_ = self->priv->_entries;
	if (_tmp2_ == NULL) {
		GeeHashMapEntrySet* _tmp3_;
		GeeSet* _tmp4_;
		GeeSet* _tmp5_;
		_tmp3_ = gee_hash_map_entry_set_new (self->priv->k_type, (GBoxedCopyFunc) self->priv->k_dup_func, self->priv->k_destroy_func, self->priv->v_type, (GBoxedCopyFunc) self->priv->v_dup_func, self->priv->v_destroy_func, self);
		_g_object_unref0 (entries);
		entries = (GeeSet*) _tmp3_;
		_tmp4_ = entries;
		self->priv->_entries = _tmp4_;
		_tmp5_ = entries;
		g_object_add_weak_pointer ((GObject*) _tmp5_, (void**) (&self->priv->_entries));
	}
	result = entries;
	return result;
}


GHashFunc gee_hash_map_get_key_hash_func (GeeHashMap* self) {
	GHashFunc result;
	GHashFunc _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_key_hash_func;
	result = _tmp0_;
	return result;
}


static void gee_hash_map_set_key_hash_func (GeeHashMap* self, GHashFunc value) {
	GHashFunc _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_key_hash_func = _tmp0_;
	g_object_notify ((GObject *) self, "key-hash-func");
}


GEqualFunc gee_hash_map_get_key_equal_func (GeeHashMap* self) {
	GEqualFunc result;
	GEqualFunc _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_key_equal_func;
	result = _tmp0_;
	return result;
}


static void gee_hash_map_set_key_equal_func (GeeHashMap* self, GEqualFunc value) {
	GEqualFunc _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_key_equal_func = _tmp0_;
	g_object_notify ((GObject *) self, "key-equal-func");
}


GEqualFunc gee_hash_map_get_value_equal_func (GeeHashMap* self) {
	GEqualFunc result;
	GEqualFunc _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_value_equal_func;
	result = _tmp0_;
	return result;
}


static void gee_hash_map_set_value_equal_func (GeeHashMap* self, GEqualFunc value) {
	GEqualFunc _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_value_equal_func = _tmp0_;
	g_object_notify ((GObject *) self, "value-equal-func");
}


static GeeHashMapNode* gee_hash_map_node_new (gpointer k, gpointer v, guint hash) {
	GeeHashMapNode* self;
	gpointer _tmp0_;
	gpointer _tmp1_;
	guint _tmp2_;
	self = g_slice_new0 (GeeHashMapNode);
	gee_hash_map_node_instance_init (self);
	_tmp0_ = k;
	k = NULL;
	self->key = _tmp0_;
	_tmp1_ = v;
	v = NULL;
	self->value = _tmp1_;
	_tmp2_ = hash;
	self->key_hash = _tmp2_;
	self->entry = NULL;
	return self;
}


static void gee_hash_map_node_instance_init (GeeHashMapNode * self) {
}


static void gee_hash_map_node_free (GeeHashMapNode* self) {
	_gee_hash_map_node_free0 (self->next);
	g_slice_free (GeeHashMapNode, self);
}


static GeeMapEntry* gee_hash_map_entry_entry_for (GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMapNode* node) {
	GeeMapEntry* result = NULL;
	GeeHashMapNode* _tmp0_;
	GeeMapEntry* _tmp1_;
	GeeMapEntry* _tmp2_;
	GeeMapEntry* _result_;
	GeeHashMapNode* _tmp3_;
	GeeMapEntry* _tmp4_;
	g_return_val_if_fail (node != NULL, NULL);
	_tmp0_ = node;
	_tmp1_ = _tmp0_->entry;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = node;
	_tmp4_ = _tmp3_->entry;
	if (_tmp4_ == NULL) {
		GeeHashMapNode* _tmp5_;
		GeeHashMapEntry* _tmp6_;
		GeeHashMapNode* _tmp7_;
		GeeMapEntry* _tmp8_;
		GeeMapEntry* _tmp9_;
		GeeHashMapNode* _tmp10_;
		_tmp5_ = node;
		_tmp6_ = gee_hash_map_entry_new (k_type, (GBoxedCopyFunc) k_dup_func, k_destroy_func, v_type, (GBoxedCopyFunc) v_dup_func, v_destroy_func, _tmp5_);
		_g_object_unref0 (_result_);
		_result_ = (GeeMapEntry*) _tmp6_;
		_tmp7_ = node;
		_tmp8_ = _result_;
		_tmp7_->entry = _tmp8_;
		_tmp9_ = _result_;
		_tmp10_ = node;
		g_object_add_weak_pointer ((GObject*) _tmp9_, (void**) (&_tmp10_->entry));
	}
	result = _result_;
	return result;
}


static GeeHashMapEntry* gee_hash_map_entry_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMapNode* node) {
	GeeHashMapEntry * self = NULL;
	GeeHashMapNode* _tmp0_;
	g_return_val_if_fail (node != NULL, NULL);
	self = (GeeHashMapEntry*) gee_map_entry_construct (object_type, k_type, (GBoxedCopyFunc) k_dup_func, k_destroy_func, v_type, (GBoxedCopyFunc) v_dup_func, v_destroy_func);
	self->priv->k_type = k_type;
	self->priv->k_dup_func = k_dup_func;
	self->priv->k_destroy_func = k_destroy_func;
	self->priv->v_type = v_type;
	self->priv->v_dup_func = v_dup_func;
	self->priv->v_destroy_func = v_destroy_func;
	_tmp0_ = node;
	self->priv->_node = _tmp0_;
	return self;
}


static GeeHashMapEntry* gee_hash_map_entry_new (GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMapNode* node) {
	return gee_hash_map_entry_construct (GEE_HASH_MAP_TYPE_ENTRY, k_type, k_dup_func, k_destroy_func, v_type, v_dup_func, v_destroy_func, node);
}


static gconstpointer gee_hash_map_entry_real_get_key (GeeMapEntry* base) {
	gconstpointer result;
	GeeHashMapEntry* self;
	GeeHashMapNode* _tmp0_;
	gconstpointer _tmp1_;
	self = (GeeHashMapEntry*) base;
	_tmp0_ = self->priv->_node;
	_tmp1_ = _tmp0_->key;
	result = _tmp1_;
	return result;
}


static gconstpointer gee_hash_map_entry_real_get_value (GeeMapEntry* base) {
	gconstpointer result;
	GeeHashMapEntry* self;
	GeeHashMapNode* _tmp0_;
	gconstpointer _tmp1_;
	self = (GeeHashMapEntry*) base;
	_tmp0_ = self->priv->_node;
	_tmp1_ = _tmp0_->value;
	result = _tmp1_;
	return result;
}


static void gee_hash_map_entry_real_set_value (GeeMapEntry* base, gconstpointer value) {
	GeeHashMapEntry* self;
	GeeHashMapNode* _tmp0_;
	gconstpointer _tmp1_;
	gpointer _tmp2_;
	self = (GeeHashMapEntry*) base;
	_tmp0_ = self->priv->_node;
	_tmp1_ = value;
	_tmp2_ = ((_tmp1_ != NULL) && (self->priv->v_dup_func != NULL)) ? self->priv->v_dup_func ((gpointer) _tmp1_) : ((gpointer) _tmp1_);
	((_tmp0_->value == NULL) || (self->priv->v_destroy_func == NULL)) ? NULL : (_tmp0_->value = (self->priv->v_destroy_func (_tmp0_->value), NULL));
	_tmp0_->value = _tmp2_;
	g_object_notify ((GObject *) self, "value");
}


static void gee_hash_map_entry_class_init (GeeHashMapEntryClass * klass) {
	gee_hash_map_entry_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GeeHashMapEntryPrivate));
	GEE_MAP_ENTRY_CLASS (klass)->get_key = gee_hash_map_entry_real_get_key;
	GEE_MAP_ENTRY_CLASS (klass)->get_value = gee_hash_map_entry_real_get_value;
	GEE_MAP_ENTRY_CLASS (klass)->set_value = gee_hash_map_entry_real_set_value;
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_hash_map_entry_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_hash_map_entry_set_property;
	G_OBJECT_CLASS (klass)->finalize = gee_hash_map_entry_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_ENTRY_K_TYPE, g_param_spec_gtype ("k-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_ENTRY_K_DUP_FUNC, g_param_spec_pointer ("k-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_ENTRY_K_DESTROY_FUNC, g_param_spec_pointer ("k-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_ENTRY_V_TYPE, g_param_spec_gtype ("v-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_ENTRY_V_DUP_FUNC, g_param_spec_pointer ("v-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_ENTRY_V_DESTROY_FUNC, g_param_spec_pointer ("v-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_ENTRY_KEY, g_param_spec_pointer ("key", "key", "key", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_ENTRY_VALUE, g_param_spec_pointer ("value", "value", "value", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void gee_hash_map_entry_instance_init (GeeHashMapEntry * self) {
	self->priv = GEE_HASH_MAP_ENTRY_GET_PRIVATE (self);
}


static void gee_hash_map_entry_finalize (GObject* obj) {
	GeeHashMapEntry * self;
	self = GEE_HASH_MAP_ENTRY (obj);
	G_OBJECT_CLASS (gee_hash_map_entry_parent_class)->finalize (obj);
}


static GType gee_hash_map_entry_get_type (void) {
	static volatile gsize gee_hash_map_entry_type_id__volatile = 0;
	if (g_once_init_enter (&gee_hash_map_entry_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GeeHashMapEntryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_hash_map_entry_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeHashMapEntry), 0, (GInstanceInitFunc) gee_hash_map_entry_instance_init, NULL };
		GType gee_hash_map_entry_type_id;
		gee_hash_map_entry_type_id = g_type_register_static (GEE_MAP_TYPE_ENTRY, "GeeHashMapEntry", &g_define_type_info, 0);
		g_once_init_leave (&gee_hash_map_entry_type_id__volatile, gee_hash_map_entry_type_id);
	}
	return gee_hash_map_entry_type_id__volatile;
}


static void _vala_gee_hash_map_entry_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GeeHashMapEntry * self;
	self = GEE_HASH_MAP_ENTRY (object);
	switch (property_id) {
		case GEE_HASH_MAP_ENTRY_KEY:
		g_value_set_pointer (value, gee_map_entry_get_key ((GeeMapEntry*) self));
		break;
		case GEE_HASH_MAP_ENTRY_VALUE:
		g_value_set_pointer (value, gee_map_entry_get_value ((GeeMapEntry*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_gee_hash_map_entry_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GeeHashMapEntry * self;
	self = GEE_HASH_MAP_ENTRY (object);
	switch (property_id) {
		case GEE_HASH_MAP_ENTRY_VALUE:
		gee_map_entry_set_value ((GeeMapEntry*) self, g_value_get_pointer (value));
		break;
		case GEE_HASH_MAP_ENTRY_K_TYPE:
		self->priv->k_type = g_value_get_gtype (value);
		break;
		case GEE_HASH_MAP_ENTRY_K_DUP_FUNC:
		self->priv->k_dup_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_ENTRY_K_DESTROY_FUNC:
		self->priv->k_destroy_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_ENTRY_V_TYPE:
		self->priv->v_type = g_value_get_gtype (value);
		break;
		case GEE_HASH_MAP_ENTRY_V_DUP_FUNC:
		self->priv->v_dup_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_ENTRY_V_DESTROY_FUNC:
		self->priv->v_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static GeeHashMapKeySet* gee_hash_map_key_set_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map) {
	GeeHashMapKeySet * self = NULL;
	GeeHashMap* _tmp0_;
	GeeHashMap* _tmp1_;
	g_return_val_if_fail (map != NULL, NULL);
	self = (GeeHashMapKeySet*) gee_abstract_set_construct (object_type, k_type, (GBoxedCopyFunc) k_dup_func, k_destroy_func);
	self->priv->k_type = k_type;
	self->priv->k_dup_func = k_dup_func;
	self->priv->k_destroy_func = k_destroy_func;
	self->priv->v_type = v_type;
	self->priv->v_dup_func = v_dup_func;
	self->priv->v_destroy_func = v_destroy_func;
	_tmp0_ = map;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_map);
	self->priv->_map = _tmp1_;
	return self;
}


static GeeHashMapKeySet* gee_hash_map_key_set_new (GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map) {
	return gee_hash_map_key_set_construct (GEE_HASH_MAP_TYPE_KEY_SET, k_type, k_dup_func, k_destroy_func, v_type, v_dup_func, v_destroy_func, map);
}


static GeeIterator* gee_hash_map_key_set_real_iterator (GeeAbstractCollection* base) {
	GeeHashMapKeySet * self;
	GeeIterator* result = NULL;
	GeeHashMap* _tmp0_;
	GeeHashMapKeyIterator* _tmp1_;
	self = (GeeHashMapKeySet*) base;
	_tmp0_ = self->priv->_map;
	_tmp1_ = gee_hash_map_key_iterator_new (self->priv->k_type, (GBoxedCopyFunc) self->priv->k_dup_func, self->priv->k_destroy_func, self->priv->v_type, (GBoxedCopyFunc) self->priv->v_dup_func, self->priv->v_destroy_func, _tmp0_);
	result = (GeeIterator*) _tmp1_;
	return result;
}


static gboolean gee_hash_map_key_set_real_add (GeeAbstractCollection* base, gconstpointer key) {
	GeeHashMapKeySet * self;
	gboolean result = FALSE;
	self = (GeeHashMapKeySet*) base;
	g_assert_not_reached ();
	return result;
}


static void gee_hash_map_key_set_real_clear (GeeAbstractCollection* base) {
	GeeHashMapKeySet * self;
	self = (GeeHashMapKeySet*) base;
	g_assert_not_reached ();
}


static gboolean gee_hash_map_key_set_real_remove (GeeAbstractCollection* base, gconstpointer key) {
	GeeHashMapKeySet * self;
	gboolean result = FALSE;
	self = (GeeHashMapKeySet*) base;
	g_assert_not_reached ();
	return result;
}


static gboolean gee_hash_map_key_set_real_contains (GeeAbstractCollection* base, gconstpointer key) {
	GeeHashMapKeySet * self;
	gboolean result = FALSE;
	GeeHashMap* _tmp0_;
	gconstpointer _tmp1_;
	gboolean _tmp2_ = FALSE;
	self = (GeeHashMapKeySet*) base;
	_tmp0_ = self->priv->_map;
	_tmp1_ = key;
	_tmp2_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


static gboolean gee_hash_map_key_set_real_add_all (GeeAbstractCollection* base, GeeCollection* collection) {
	GeeHashMapKeySet * self;
	gboolean result = FALSE;
	self = (GeeHashMapKeySet*) base;
	g_return_val_if_fail (collection != NULL, FALSE);
	g_assert_not_reached ();
	return result;
}


static gboolean gee_hash_map_key_set_real_remove_all (GeeAbstractCollection* base, GeeCollection* collection) {
	GeeHashMapKeySet * self;
	gboolean result = FALSE;
	self = (GeeHashMapKeySet*) base;
	g_return_val_if_fail (collection != NULL, FALSE);
	g_assert_not_reached ();
	return result;
}


static gboolean gee_hash_map_key_set_real_retain_all (GeeAbstractCollection* base, GeeCollection* collection) {
	GeeHashMapKeySet * self;
	gboolean result = FALSE;
	self = (GeeHashMapKeySet*) base;
	g_return_val_if_fail (collection != NULL, FALSE);
	g_assert_not_reached ();
	return result;
}


static gint gee_hash_map_key_set_real_get_size (GeeAbstractCollection* base) {
	gint result;
	GeeHashMapKeySet* self;
	GeeHashMap* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	self = (GeeHashMapKeySet*) base;
	_tmp0_ = self->priv->_map;
	_tmp1_ = gee_map_get_size ((GeeMap*) _tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


static void gee_hash_map_key_set_class_init (GeeHashMapKeySetClass * klass) {
	gee_hash_map_key_set_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GeeHashMapKeySetPrivate));
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->iterator = gee_hash_map_key_set_real_iterator;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->add = gee_hash_map_key_set_real_add;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->clear = gee_hash_map_key_set_real_clear;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->remove = gee_hash_map_key_set_real_remove;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->contains = gee_hash_map_key_set_real_contains;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->add_all = gee_hash_map_key_set_real_add_all;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->remove_all = gee_hash_map_key_set_real_remove_all;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->retain_all = gee_hash_map_key_set_real_retain_all;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->get_size = gee_hash_map_key_set_real_get_size;
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_hash_map_key_set_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_hash_map_key_set_set_property;
	G_OBJECT_CLASS (klass)->finalize = gee_hash_map_key_set_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_KEY_SET_K_TYPE, g_param_spec_gtype ("k-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_KEY_SET_K_DUP_FUNC, g_param_spec_pointer ("k-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_KEY_SET_K_DESTROY_FUNC, g_param_spec_pointer ("k-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_KEY_SET_V_TYPE, g_param_spec_gtype ("v-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_KEY_SET_V_DUP_FUNC, g_param_spec_pointer ("v-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_KEY_SET_V_DESTROY_FUNC, g_param_spec_pointer ("v-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_KEY_SET_SIZE, g_param_spec_int ("size", "size", "size", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void gee_hash_map_key_set_instance_init (GeeHashMapKeySet * self) {
	self->priv = GEE_HASH_MAP_KEY_SET_GET_PRIVATE (self);
}


static void gee_hash_map_key_set_finalize (GObject* obj) {
	GeeHashMapKeySet * self;
	self = GEE_HASH_MAP_KEY_SET (obj);
	_g_object_unref0 (self->priv->_map);
	G_OBJECT_CLASS (gee_hash_map_key_set_parent_class)->finalize (obj);
}


static GType gee_hash_map_key_set_get_type (void) {
	static volatile gsize gee_hash_map_key_set_type_id__volatile = 0;
	if (g_once_init_enter (&gee_hash_map_key_set_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GeeHashMapKeySetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_hash_map_key_set_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeHashMapKeySet), 0, (GInstanceInitFunc) gee_hash_map_key_set_instance_init, NULL };
		GType gee_hash_map_key_set_type_id;
		gee_hash_map_key_set_type_id = g_type_register_static (GEE_TYPE_ABSTRACT_SET, "GeeHashMapKeySet", &g_define_type_info, 0);
		g_once_init_leave (&gee_hash_map_key_set_type_id__volatile, gee_hash_map_key_set_type_id);
	}
	return gee_hash_map_key_set_type_id__volatile;
}


static void _vala_gee_hash_map_key_set_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GeeHashMapKeySet * self;
	self = GEE_HASH_MAP_KEY_SET (object);
	switch (property_id) {
		case GEE_HASH_MAP_KEY_SET_SIZE:
		g_value_set_int (value, gee_abstract_collection_get_size ((GeeAbstractCollection*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_gee_hash_map_key_set_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GeeHashMapKeySet * self;
	self = GEE_HASH_MAP_KEY_SET (object);
	switch (property_id) {
		case GEE_HASH_MAP_KEY_SET_K_TYPE:
		self->priv->k_type = g_value_get_gtype (value);
		break;
		case GEE_HASH_MAP_KEY_SET_K_DUP_FUNC:
		self->priv->k_dup_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_KEY_SET_K_DESTROY_FUNC:
		self->priv->k_destroy_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_KEY_SET_V_TYPE:
		self->priv->v_type = g_value_get_gtype (value);
		break;
		case GEE_HASH_MAP_KEY_SET_V_DUP_FUNC:
		self->priv->v_dup_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_KEY_SET_V_DESTROY_FUNC:
		self->priv->v_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static GeeHashMapValueCollection* gee_hash_map_value_collection_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map) {
	GeeHashMapValueCollection * self = NULL;
	GeeHashMap* _tmp0_;
	GeeHashMap* _tmp1_;
	g_return_val_if_fail (map != NULL, NULL);
	self = (GeeHashMapValueCollection*) gee_abstract_collection_construct (object_type, v_type, (GBoxedCopyFunc) v_dup_func, v_destroy_func);
	self->priv->k_type = k_type;
	self->priv->k_dup_func = k_dup_func;
	self->priv->k_destroy_func = k_destroy_func;
	self->priv->v_type = v_type;
	self->priv->v_dup_func = v_dup_func;
	self->priv->v_destroy_func = v_destroy_func;
	_tmp0_ = map;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_map);
	self->priv->_map = _tmp1_;
	return self;
}


static GeeHashMapValueCollection* gee_hash_map_value_collection_new (GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map) {
	return gee_hash_map_value_collection_construct (GEE_HASH_MAP_TYPE_VALUE_COLLECTION, k_type, k_dup_func, k_destroy_func, v_type, v_dup_func, v_destroy_func, map);
}


static GeeIterator* gee_hash_map_value_collection_real_iterator (GeeAbstractCollection* base) {
	GeeHashMapValueCollection * self;
	GeeIterator* result = NULL;
	GeeHashMap* _tmp0_;
	GeeHashMapValueIterator* _tmp1_;
	self = (GeeHashMapValueCollection*) base;
	_tmp0_ = self->priv->_map;
	_tmp1_ = gee_hash_map_value_iterator_new (self->priv->k_type, (GBoxedCopyFunc) self->priv->k_dup_func, self->priv->k_destroy_func, self->priv->v_type, (GBoxedCopyFunc) self->priv->v_dup_func, self->priv->v_destroy_func, _tmp0_);
	result = (GeeIterator*) _tmp1_;
	return result;
}


static gboolean gee_hash_map_value_collection_real_add (GeeAbstractCollection* base, gconstpointer value) {
	GeeHashMapValueCollection * self;
	gboolean result = FALSE;
	self = (GeeHashMapValueCollection*) base;
	g_assert_not_reached ();
	return result;
}


static void gee_hash_map_value_collection_real_clear (GeeAbstractCollection* base) {
	GeeHashMapValueCollection * self;
	self = (GeeHashMapValueCollection*) base;
	g_assert_not_reached ();
}


static gboolean gee_hash_map_value_collection_real_remove (GeeAbstractCollection* base, gconstpointer value) {
	GeeHashMapValueCollection * self;
	gboolean result = FALSE;
	self = (GeeHashMapValueCollection*) base;
	g_assert_not_reached ();
	return result;
}


static gboolean gee_hash_map_value_collection_real_contains (GeeAbstractCollection* base, gconstpointer value) {
	GeeHashMapValueCollection * self;
	gboolean result = FALSE;
	GeeIterator* _tmp0_ = NULL;
	GeeIterator* it;
	self = (GeeHashMapValueCollection*) base;
	_tmp0_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) self);
	it = _tmp0_;
	while (TRUE) {
		GeeIterator* _tmp1_;
		gboolean _tmp2_ = FALSE;
		GeeHashMap* _tmp3_;
		GEqualFunc _tmp4_;
		GEqualFunc _tmp5_;
		GeeIterator* _tmp6_;
		gpointer _tmp7_ = NULL;
		gpointer _tmp8_;
		gconstpointer _tmp9_;
		gboolean _tmp10_ = FALSE;
		gboolean _tmp11_;
		_tmp1_ = it;
		_tmp2_ = gee_iterator_next (_tmp1_);
		if (!_tmp2_) {
			break;
		}
		_tmp3_ = self->priv->_map;
		_tmp4_ = gee_hash_map_get_value_equal_func (_tmp3_);
		_tmp5_ = _tmp4_;
		_tmp6_ = it;
		_tmp7_ = gee_iterator_get (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = value;
		_tmp10_ = _tmp5_ (_tmp8_, _tmp9_);
		_tmp11_ = _tmp10_;
		((_tmp8_ == NULL) || (self->priv->v_destroy_func == NULL)) ? NULL : (_tmp8_ = (self->priv->v_destroy_func (_tmp8_), NULL));
		if (_tmp11_) {
			result = TRUE;
			_g_object_unref0 (it);
			return result;
		}
	}
	result = FALSE;
	_g_object_unref0 (it);
	return result;
}


static gboolean gee_hash_map_value_collection_real_add_all (GeeAbstractCollection* base, GeeCollection* collection) {
	GeeHashMapValueCollection * self;
	gboolean result = FALSE;
	self = (GeeHashMapValueCollection*) base;
	g_return_val_if_fail (collection != NULL, FALSE);
	g_assert_not_reached ();
	return result;
}


static gboolean gee_hash_map_value_collection_real_remove_all (GeeAbstractCollection* base, GeeCollection* collection) {
	GeeHashMapValueCollection * self;
	gboolean result = FALSE;
	self = (GeeHashMapValueCollection*) base;
	g_return_val_if_fail (collection != NULL, FALSE);
	g_assert_not_reached ();
	return result;
}


static gboolean gee_hash_map_value_collection_real_retain_all (GeeAbstractCollection* base, GeeCollection* collection) {
	GeeHashMapValueCollection * self;
	gboolean result = FALSE;
	self = (GeeHashMapValueCollection*) base;
	g_return_val_if_fail (collection != NULL, FALSE);
	g_assert_not_reached ();
	return result;
}


static gint gee_hash_map_value_collection_real_get_size (GeeAbstractCollection* base) {
	gint result;
	GeeHashMapValueCollection* self;
	GeeHashMap* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	self = (GeeHashMapValueCollection*) base;
	_tmp0_ = self->priv->_map;
	_tmp1_ = gee_map_get_size ((GeeMap*) _tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


static void gee_hash_map_value_collection_class_init (GeeHashMapValueCollectionClass * klass) {
	gee_hash_map_value_collection_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GeeHashMapValueCollectionPrivate));
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->iterator = gee_hash_map_value_collection_real_iterator;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->add = gee_hash_map_value_collection_real_add;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->clear = gee_hash_map_value_collection_real_clear;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->remove = gee_hash_map_value_collection_real_remove;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->contains = gee_hash_map_value_collection_real_contains;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->add_all = gee_hash_map_value_collection_real_add_all;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->remove_all = gee_hash_map_value_collection_real_remove_all;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->retain_all = gee_hash_map_value_collection_real_retain_all;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->get_size = gee_hash_map_value_collection_real_get_size;
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_hash_map_value_collection_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_hash_map_value_collection_set_property;
	G_OBJECT_CLASS (klass)->finalize = gee_hash_map_value_collection_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_VALUE_COLLECTION_K_TYPE, g_param_spec_gtype ("k-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_VALUE_COLLECTION_K_DUP_FUNC, g_param_spec_pointer ("k-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_VALUE_COLLECTION_K_DESTROY_FUNC, g_param_spec_pointer ("k-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_VALUE_COLLECTION_V_TYPE, g_param_spec_gtype ("v-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_VALUE_COLLECTION_V_DUP_FUNC, g_param_spec_pointer ("v-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_VALUE_COLLECTION_V_DESTROY_FUNC, g_param_spec_pointer ("v-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_VALUE_COLLECTION_SIZE, g_param_spec_int ("size", "size", "size", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void gee_hash_map_value_collection_instance_init (GeeHashMapValueCollection * self) {
	self->priv = GEE_HASH_MAP_VALUE_COLLECTION_GET_PRIVATE (self);
}


static void gee_hash_map_value_collection_finalize (GObject* obj) {
	GeeHashMapValueCollection * self;
	self = GEE_HASH_MAP_VALUE_COLLECTION (obj);
	_g_object_unref0 (self->priv->_map);
	G_OBJECT_CLASS (gee_hash_map_value_collection_parent_class)->finalize (obj);
}


static GType gee_hash_map_value_collection_get_type (void) {
	static volatile gsize gee_hash_map_value_collection_type_id__volatile = 0;
	if (g_once_init_enter (&gee_hash_map_value_collection_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GeeHashMapValueCollectionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_hash_map_value_collection_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeHashMapValueCollection), 0, (GInstanceInitFunc) gee_hash_map_value_collection_instance_init, NULL };
		GType gee_hash_map_value_collection_type_id;
		gee_hash_map_value_collection_type_id = g_type_register_static (GEE_TYPE_ABSTRACT_COLLECTION, "GeeHashMapValueCollection", &g_define_type_info, 0);
		g_once_init_leave (&gee_hash_map_value_collection_type_id__volatile, gee_hash_map_value_collection_type_id);
	}
	return gee_hash_map_value_collection_type_id__volatile;
}


static void _vala_gee_hash_map_value_collection_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GeeHashMapValueCollection * self;
	self = GEE_HASH_MAP_VALUE_COLLECTION (object);
	switch (property_id) {
		case GEE_HASH_MAP_VALUE_COLLECTION_SIZE:
		g_value_set_int (value, gee_abstract_collection_get_size ((GeeAbstractCollection*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_gee_hash_map_value_collection_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GeeHashMapValueCollection * self;
	self = GEE_HASH_MAP_VALUE_COLLECTION (object);
	switch (property_id) {
		case GEE_HASH_MAP_VALUE_COLLECTION_K_TYPE:
		self->priv->k_type = g_value_get_gtype (value);
		break;
		case GEE_HASH_MAP_VALUE_COLLECTION_K_DUP_FUNC:
		self->priv->k_dup_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_VALUE_COLLECTION_K_DESTROY_FUNC:
		self->priv->k_destroy_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_VALUE_COLLECTION_V_TYPE:
		self->priv->v_type = g_value_get_gtype (value);
		break;
		case GEE_HASH_MAP_VALUE_COLLECTION_V_DUP_FUNC:
		self->priv->v_dup_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_VALUE_COLLECTION_V_DESTROY_FUNC:
		self->priv->v_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static GeeHashMapEntrySet* gee_hash_map_entry_set_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map) {
	GeeHashMapEntrySet * self = NULL;
	GeeHashMap* _tmp0_;
	GeeHashMap* _tmp1_;
	g_return_val_if_fail (map != NULL, NULL);
	self = (GeeHashMapEntrySet*) gee_abstract_set_construct (object_type, GEE_MAP_TYPE_ENTRY, (GBoxedCopyFunc) g_object_ref, g_object_unref);
	self->priv->k_type = k_type;
	self->priv->k_dup_func = k_dup_func;
	self->priv->k_destroy_func = k_destroy_func;
	self->priv->v_type = v_type;
	self->priv->v_dup_func = v_dup_func;
	self->priv->v_destroy_func = v_destroy_func;
	_tmp0_ = map;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_map);
	self->priv->_map = _tmp1_;
	return self;
}


static GeeHashMapEntrySet* gee_hash_map_entry_set_new (GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map) {
	return gee_hash_map_entry_set_construct (GEE_HASH_MAP_TYPE_ENTRY_SET, k_type, k_dup_func, k_destroy_func, v_type, v_dup_func, v_destroy_func, map);
}


static GeeIterator* gee_hash_map_entry_set_real_iterator (GeeAbstractCollection* base) {
	GeeHashMapEntrySet * self;
	GeeIterator* result = NULL;
	GeeHashMap* _tmp0_;
	GeeHashMapEntryIterator* _tmp1_;
	self = (GeeHashMapEntrySet*) base;
	_tmp0_ = self->priv->_map;
	_tmp1_ = gee_hash_map_entry_iterator_new (self->priv->k_type, (GBoxedCopyFunc) self->priv->k_dup_func, self->priv->k_destroy_func, self->priv->v_type, (GBoxedCopyFunc) self->priv->v_dup_func, self->priv->v_destroy_func, _tmp0_);
	result = (GeeIterator*) _tmp1_;
	return result;
}


static gboolean gee_hash_map_entry_set_real_add (GeeAbstractCollection* base, GeeMapEntry* entry) {
	GeeHashMapEntrySet * self;
	gboolean result = FALSE;
	self = (GeeHashMapEntrySet*) base;
	g_return_val_if_fail (entry != NULL, FALSE);
	g_assert_not_reached ();
	return result;
}


static void gee_hash_map_entry_set_real_clear (GeeAbstractCollection* base) {
	GeeHashMapEntrySet * self;
	self = (GeeHashMapEntrySet*) base;
	g_assert_not_reached ();
}


static gboolean gee_hash_map_entry_set_real_remove (GeeAbstractCollection* base, GeeMapEntry* entry) {
	GeeHashMapEntrySet * self;
	gboolean result = FALSE;
	self = (GeeHashMapEntrySet*) base;
	g_return_val_if_fail (entry != NULL, FALSE);
	g_assert_not_reached ();
	return result;
}


static gboolean gee_hash_map_entry_set_real_contains (GeeAbstractCollection* base, GeeMapEntry* entry) {
	GeeHashMapEntrySet * self;
	gboolean result = FALSE;
	GeeHashMap* _tmp0_;
	GeeMapEntry* _tmp1_;
	gconstpointer _tmp2_;
	gconstpointer _tmp3_;
	GeeMapEntry* _tmp4_;
	gconstpointer _tmp5_;
	gconstpointer _tmp6_;
	gboolean _tmp7_ = FALSE;
	self = (GeeHashMapEntrySet*) base;
	g_return_val_if_fail (entry != NULL, FALSE);
	_tmp0_ = self->priv->_map;
	_tmp1_ = entry;
	_tmp2_ = gee_map_entry_get_key (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = entry;
	_tmp5_ = gee_map_entry_get_value (_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = gee_abstract_map_has ((GeeAbstractMap*) _tmp0_, _tmp3_, _tmp6_);
	result = _tmp7_;
	return result;
}


static gboolean gee_hash_map_entry_set_real_add_all (GeeAbstractCollection* base, GeeCollection* entries) {
	GeeHashMapEntrySet * self;
	gboolean result = FALSE;
	self = (GeeHashMapEntrySet*) base;
	g_return_val_if_fail (entries != NULL, FALSE);
	g_assert_not_reached ();
	return result;
}


static gboolean gee_hash_map_entry_set_real_remove_all (GeeAbstractCollection* base, GeeCollection* entries) {
	GeeHashMapEntrySet * self;
	gboolean result = FALSE;
	self = (GeeHashMapEntrySet*) base;
	g_return_val_if_fail (entries != NULL, FALSE);
	g_assert_not_reached ();
	return result;
}


static gboolean gee_hash_map_entry_set_real_retain_all (GeeAbstractCollection* base, GeeCollection* entries) {
	GeeHashMapEntrySet * self;
	gboolean result = FALSE;
	self = (GeeHashMapEntrySet*) base;
	g_return_val_if_fail (entries != NULL, FALSE);
	g_assert_not_reached ();
	return result;
}


static gint gee_hash_map_entry_set_real_get_size (GeeAbstractCollection* base) {
	gint result;
	GeeHashMapEntrySet* self;
	GeeHashMap* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	self = (GeeHashMapEntrySet*) base;
	_tmp0_ = self->priv->_map;
	_tmp1_ = gee_map_get_size ((GeeMap*) _tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


static void gee_hash_map_entry_set_class_init (GeeHashMapEntrySetClass * klass) {
	gee_hash_map_entry_set_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GeeHashMapEntrySetPrivate));
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->iterator = gee_hash_map_entry_set_real_iterator;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->add = gee_hash_map_entry_set_real_add;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->clear = gee_hash_map_entry_set_real_clear;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->remove = gee_hash_map_entry_set_real_remove;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->contains = gee_hash_map_entry_set_real_contains;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->add_all = gee_hash_map_entry_set_real_add_all;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->remove_all = gee_hash_map_entry_set_real_remove_all;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->retain_all = gee_hash_map_entry_set_real_retain_all;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->get_size = gee_hash_map_entry_set_real_get_size;
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_hash_map_entry_set_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_hash_map_entry_set_set_property;
	G_OBJECT_CLASS (klass)->finalize = gee_hash_map_entry_set_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_ENTRY_SET_K_TYPE, g_param_spec_gtype ("k-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_ENTRY_SET_K_DUP_FUNC, g_param_spec_pointer ("k-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_ENTRY_SET_K_DESTROY_FUNC, g_param_spec_pointer ("k-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_ENTRY_SET_V_TYPE, g_param_spec_gtype ("v-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_ENTRY_SET_V_DUP_FUNC, g_param_spec_pointer ("v-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_ENTRY_SET_V_DESTROY_FUNC, g_param_spec_pointer ("v-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_ENTRY_SET_SIZE, g_param_spec_int ("size", "size", "size", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void gee_hash_map_entry_set_instance_init (GeeHashMapEntrySet * self) {
	self->priv = GEE_HASH_MAP_ENTRY_SET_GET_PRIVATE (self);
}


static void gee_hash_map_entry_set_finalize (GObject* obj) {
	GeeHashMapEntrySet * self;
	self = GEE_HASH_MAP_ENTRY_SET (obj);
	_g_object_unref0 (self->priv->_map);
	G_OBJECT_CLASS (gee_hash_map_entry_set_parent_class)->finalize (obj);
}


static GType gee_hash_map_entry_set_get_type (void) {
	static volatile gsize gee_hash_map_entry_set_type_id__volatile = 0;
	if (g_once_init_enter (&gee_hash_map_entry_set_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GeeHashMapEntrySetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_hash_map_entry_set_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeHashMapEntrySet), 0, (GInstanceInitFunc) gee_hash_map_entry_set_instance_init, NULL };
		GType gee_hash_map_entry_set_type_id;
		gee_hash_map_entry_set_type_id = g_type_register_static (GEE_TYPE_ABSTRACT_SET, "GeeHashMapEntrySet", &g_define_type_info, 0);
		g_once_init_leave (&gee_hash_map_entry_set_type_id__volatile, gee_hash_map_entry_set_type_id);
	}
	return gee_hash_map_entry_set_type_id__volatile;
}


static void _vala_gee_hash_map_entry_set_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GeeHashMapEntrySet * self;
	self = GEE_HASH_MAP_ENTRY_SET (object);
	switch (property_id) {
		case GEE_HASH_MAP_ENTRY_SET_SIZE:
		g_value_set_int (value, gee_abstract_collection_get_size ((GeeAbstractCollection*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_gee_hash_map_entry_set_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GeeHashMapEntrySet * self;
	self = GEE_HASH_MAP_ENTRY_SET (object);
	switch (property_id) {
		case GEE_HASH_MAP_ENTRY_SET_K_TYPE:
		self->priv->k_type = g_value_get_gtype (value);
		break;
		case GEE_HASH_MAP_ENTRY_SET_K_DUP_FUNC:
		self->priv->k_dup_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_ENTRY_SET_K_DESTROY_FUNC:
		self->priv->k_destroy_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_ENTRY_SET_V_TYPE:
		self->priv->v_type = g_value_get_gtype (value);
		break;
		case GEE_HASH_MAP_ENTRY_SET_V_DUP_FUNC:
		self->priv->v_dup_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_ENTRY_SET_V_DESTROY_FUNC:
		self->priv->v_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static GeeHashMapNodeIterator* gee_hash_map_node_iterator_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map) {
	GeeHashMapNodeIterator * self = NULL;
	GeeHashMap* _tmp0_;
	GeeHashMap* _tmp1_;
	GeeHashMap* _tmp2_;
	gint _tmp3_;
	g_return_val_if_fail (map != NULL, NULL);
	self = (GeeHashMapNodeIterator*) g_object_new (object_type, NULL);
	self->priv->k_type = k_type;
	self->priv->k_dup_func = k_dup_func;
	self->priv->k_destroy_func = k_destroy_func;
	self->priv->v_type = v_type;
	self->priv->v_dup_func = v_dup_func;
	self->priv->v_destroy_func = v_destroy_func;
	_tmp0_ = map;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->_map);
	self->_map = _tmp1_;
	_tmp2_ = self->_map;
	_tmp3_ = _tmp2_->priv->_stamp;
	self->_stamp = _tmp3_;
	return self;
}


static gboolean gee_hash_map_node_iterator_next (GeeHashMapNodeIterator* self) {
	gboolean result = FALSE;
	gint _tmp0_;
	GeeHashMap* _tmp1_;
	gint _tmp2_;
	gboolean _tmp3_ = FALSE;
	GeeHashMapNode* _tmp4_;
	GeeHashMapNode* _tmp5_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->_stamp;
	_tmp1_ = self->_map;
	_tmp2_ = _tmp1_->priv->_stamp;
	g_assert (_tmp0_ == _tmp2_);
	_tmp3_ = gee_hash_map_node_iterator_has_next (self);
	if (!_tmp3_) {
		result = FALSE;
		return result;
	}
	_tmp4_ = self->_next;
	self->_node = _tmp4_;
	self->_next = NULL;
	_tmp5_ = self->_node;
	result = _tmp5_ != NULL;
	return result;
}


static gboolean gee_hash_map_node_iterator_has_next (GeeHashMapNodeIterator* self) {
	gboolean result = FALSE;
	gint _tmp0_;
	GeeHashMap* _tmp1_;
	gint _tmp2_;
	GeeHashMapNode* _tmp3_;
	GeeHashMapNode* _tmp19_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->_stamp;
	_tmp1_ = self->_map;
	_tmp2_ = _tmp1_->priv->_stamp;
	g_assert (_tmp0_ == _tmp2_);
	_tmp3_ = self->_next;
	if (_tmp3_ == NULL) {
		GeeHashMapNode* _tmp4_;
		GeeHashMapNode* _tmp5_;
		_tmp4_ = self->_node;
		self->_next = _tmp4_;
		_tmp5_ = self->_next;
		if (_tmp5_ != NULL) {
			GeeHashMapNode* _tmp6_;
			GeeHashMapNode* _tmp7_;
			_tmp6_ = self->_next;
			_tmp7_ = _tmp6_->next;
			self->_next = _tmp7_;
		}
		while (TRUE) {
			gboolean _tmp8_ = FALSE;
			GeeHashMapNode* _tmp9_;
			gboolean _tmp13_;
			gint _tmp14_;
			GeeHashMap* _tmp15_;
			GeeHashMapNode** _tmp16_;
			gint _tmp16__length1;
			gint _tmp17_;
			GeeHashMapNode* _tmp18_;
			_tmp9_ = self->_next;
			if (_tmp9_ == NULL) {
				gint _tmp10_;
				GeeHashMap* _tmp11_;
				gint _tmp12_;
				_tmp10_ = self->priv->_index;
				_tmp11_ = self->_map;
				_tmp12_ = _tmp11_->priv->_array_size;
				_tmp8_ = (_tmp10_ + 1) < _tmp12_;
			} else {
				_tmp8_ = FALSE;
			}
			_tmp13_ = _tmp8_;
			if (!_tmp13_) {
				break;
			}
			_tmp14_ = self->priv->_index;
			self->priv->_index = _tmp14_ + 1;
			_tmp15_ = self->_map;
			_tmp16_ = _tmp15_->priv->_nodes;
			_tmp16__length1 = _tmp15_->priv->_nodes_length1;
			_tmp17_ = self->priv->_index;
			_tmp18_ = _tmp16_[_tmp17_];
			self->_next = _tmp18_;
		}
	}
	_tmp19_ = self->_next;
	result = _tmp19_ != NULL;
	return result;
}


static gboolean gee_hash_map_node_iterator_first (GeeHashMapNodeIterator* self) {
	gboolean result = FALSE;
	gint _tmp0_;
	GeeHashMap* _tmp1_;
	gint _tmp2_;
	GeeHashMap* _tmp3_;
	gint _tmp4_;
	gint _tmp5_;
	gboolean _tmp6_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->_stamp;
	_tmp1_ = self->_map;
	_tmp2_ = _tmp1_->priv->_stamp;
	g_assert (_tmp0_ == _tmp2_);
	_tmp3_ = self->_map;
	_tmp4_ = gee_map_get_size ((GeeMap*) _tmp3_);
	_tmp5_ = _tmp4_;
	if (_tmp5_ == 0) {
		result = FALSE;
		return result;
	}
	self->priv->_index = -1;
	self->_next = NULL;
	_tmp6_ = gee_hash_map_node_iterator_next (self);
	result = _tmp6_;
	return result;
}


static void gee_hash_map_node_iterator_class_init (GeeHashMapNodeIteratorClass * klass) {
	gee_hash_map_node_iterator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GeeHashMapNodeIteratorPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_hash_map_node_iterator_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_hash_map_node_iterator_set_property;
	G_OBJECT_CLASS (klass)->finalize = gee_hash_map_node_iterator_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_NODE_ITERATOR_K_TYPE, g_param_spec_gtype ("k-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_NODE_ITERATOR_K_DUP_FUNC, g_param_spec_pointer ("k-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_NODE_ITERATOR_K_DESTROY_FUNC, g_param_spec_pointer ("k-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_NODE_ITERATOR_V_TYPE, g_param_spec_gtype ("v-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_NODE_ITERATOR_V_DUP_FUNC, g_param_spec_pointer ("v-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_NODE_ITERATOR_V_DESTROY_FUNC, g_param_spec_pointer ("v-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}


static void gee_hash_map_node_iterator_instance_init (GeeHashMapNodeIterator * self) {
	self->priv = GEE_HASH_MAP_NODE_ITERATOR_GET_PRIVATE (self);
	self->priv->_index = -1;
}


static void gee_hash_map_node_iterator_finalize (GObject* obj) {
	GeeHashMapNodeIterator * self;
	self = GEE_HASH_MAP_NODE_ITERATOR (obj);
	_g_object_unref0 (self->_map);
	G_OBJECT_CLASS (gee_hash_map_node_iterator_parent_class)->finalize (obj);
}


static GType gee_hash_map_node_iterator_get_type (void) {
	static volatile gsize gee_hash_map_node_iterator_type_id__volatile = 0;
	if (g_once_init_enter (&gee_hash_map_node_iterator_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GeeHashMapNodeIteratorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_hash_map_node_iterator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeHashMapNodeIterator), 0, (GInstanceInitFunc) gee_hash_map_node_iterator_instance_init, NULL };
		GType gee_hash_map_node_iterator_type_id;
		gee_hash_map_node_iterator_type_id = g_type_register_static (G_TYPE_OBJECT, "GeeHashMapNodeIterator", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&gee_hash_map_node_iterator_type_id__volatile, gee_hash_map_node_iterator_type_id);
	}
	return gee_hash_map_node_iterator_type_id__volatile;
}


static void _vala_gee_hash_map_node_iterator_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GeeHashMapNodeIterator * self;
	self = GEE_HASH_MAP_NODE_ITERATOR (object);
	switch (property_id) {
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_gee_hash_map_node_iterator_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GeeHashMapNodeIterator * self;
	self = GEE_HASH_MAP_NODE_ITERATOR (object);
	switch (property_id) {
		case GEE_HASH_MAP_NODE_ITERATOR_K_TYPE:
		self->priv->k_type = g_value_get_gtype (value);
		break;
		case GEE_HASH_MAP_NODE_ITERATOR_K_DUP_FUNC:
		self->priv->k_dup_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_NODE_ITERATOR_K_DESTROY_FUNC:
		self->priv->k_destroy_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_NODE_ITERATOR_V_TYPE:
		self->priv->v_type = g_value_get_gtype (value);
		break;
		case GEE_HASH_MAP_NODE_ITERATOR_V_DUP_FUNC:
		self->priv->v_dup_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_NODE_ITERATOR_V_DESTROY_FUNC:
		self->priv->v_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static GeeHashMapKeyIterator* gee_hash_map_key_iterator_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map) {
	GeeHashMapKeyIterator * self = NULL;
	GeeHashMap* _tmp0_;
	g_return_val_if_fail (map != NULL, NULL);
	_tmp0_ = map;
	self = (GeeHashMapKeyIterator*) gee_hash_map_node_iterator_construct (object_type, k_type, (GBoxedCopyFunc) k_dup_func, k_destroy_func, v_type, (GBoxedCopyFunc) v_dup_func, v_destroy_func, _tmp0_);
	self->priv->k_type = k_type;
	self->priv->k_dup_func = k_dup_func;
	self->priv->k_destroy_func = k_destroy_func;
	self->priv->v_type = v_type;
	self->priv->v_dup_func = v_dup_func;
	self->priv->v_destroy_func = v_destroy_func;
	return self;
}


static GeeHashMapKeyIterator* gee_hash_map_key_iterator_new (GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map) {
	return gee_hash_map_key_iterator_construct (GEE_HASH_MAP_TYPE_KEY_ITERATOR, k_type, k_dup_func, k_destroy_func, v_type, v_dup_func, v_destroy_func, map);
}


static gpointer gee_hash_map_key_iterator_real_get (GeeIterator* base) {
	GeeHashMapKeyIterator * self;
	gpointer result = NULL;
	gint _tmp0_;
	GeeHashMap* _tmp1_;
	gint _tmp2_;
	GeeHashMapNode* _tmp3_;
	GeeHashMapNode* _tmp4_;
	gconstpointer _tmp5_;
	gpointer _tmp6_;
	self = (GeeHashMapKeyIterator*) base;
	_tmp0_ = ((GeeHashMapNodeIterator*) self)->_stamp;
	_tmp1_ = ((GeeHashMapNodeIterator*) self)->_map;
	_tmp2_ = _tmp1_->priv->_stamp;
	g_assert (_tmp0_ == _tmp2_);
	_tmp3_ = ((GeeHashMapNodeIterator*) self)->_node;
	g_assert (_tmp3_ != NULL);
	_tmp4_ = ((GeeHashMapNodeIterator*) self)->_node;
	_tmp5_ = _tmp4_->key;
	_tmp6_ = ((_tmp5_ != NULL) && (self->priv->k_dup_func != NULL)) ? self->priv->k_dup_func ((gpointer) _tmp5_) : ((gpointer) _tmp5_);
	result = _tmp6_;
	return result;
}


static void gee_hash_map_key_iterator_real_remove (GeeIterator* base) {
	GeeHashMapKeyIterator * self;
	self = (GeeHashMapKeyIterator*) base;
	g_assert_not_reached ();
}


static void gee_hash_map_key_iterator_class_init (GeeHashMapKeyIteratorClass * klass) {
	gee_hash_map_key_iterator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GeeHashMapKeyIteratorPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_hash_map_key_iterator_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_hash_map_key_iterator_set_property;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_KEY_ITERATOR_K_TYPE, g_param_spec_gtype ("k-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_KEY_ITERATOR_K_DUP_FUNC, g_param_spec_pointer ("k-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_KEY_ITERATOR_K_DESTROY_FUNC, g_param_spec_pointer ("k-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_KEY_ITERATOR_V_TYPE, g_param_spec_gtype ("v-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_KEY_ITERATOR_V_DUP_FUNC, g_param_spec_pointer ("v-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_KEY_ITERATOR_V_DESTROY_FUNC, g_param_spec_pointer ("v-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}


static void gee_hash_map_key_iterator_gee_iterator_interface_init (GeeIteratorIface * iface) {
	gee_hash_map_key_iterator_gee_iterator_parent_iface = g_type_interface_peek_parent (iface);
	iface->get = (gpointer (*)(GeeIterator*)) gee_hash_map_key_iterator_real_get;
	iface->remove = (void (*)(GeeIterator*)) gee_hash_map_key_iterator_real_remove;
	iface->next = (gboolean (*)(GeeIterator*)) gee_hash_map_node_iterator_next;
	iface->has_next = (gboolean (*)(GeeIterator*)) gee_hash_map_node_iterator_has_next;
	iface->first = (gboolean (*)(GeeIterator*)) gee_hash_map_node_iterator_first;
}


static void gee_hash_map_key_iterator_instance_init (GeeHashMapKeyIterator * self) {
	self->priv = GEE_HASH_MAP_KEY_ITERATOR_GET_PRIVATE (self);
}


static GType gee_hash_map_key_iterator_get_type (void) {
	static volatile gsize gee_hash_map_key_iterator_type_id__volatile = 0;
	if (g_once_init_enter (&gee_hash_map_key_iterator_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GeeHashMapKeyIteratorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_hash_map_key_iterator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeHashMapKeyIterator), 0, (GInstanceInitFunc) gee_hash_map_key_iterator_instance_init, NULL };
		static const GInterfaceInfo gee_iterator_info = { (GInterfaceInitFunc) gee_hash_map_key_iterator_gee_iterator_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType gee_hash_map_key_iterator_type_id;
		gee_hash_map_key_iterator_type_id = g_type_register_static (GEE_HASH_MAP_TYPE_NODE_ITERATOR, "GeeHashMapKeyIterator", &g_define_type_info, 0);
		g_type_add_interface_static (gee_hash_map_key_iterator_type_id, GEE_TYPE_ITERATOR, &gee_iterator_info);
		g_once_init_leave (&gee_hash_map_key_iterator_type_id__volatile, gee_hash_map_key_iterator_type_id);
	}
	return gee_hash_map_key_iterator_type_id__volatile;
}


static void _vala_gee_hash_map_key_iterator_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GeeHashMapKeyIterator * self;
	self = GEE_HASH_MAP_KEY_ITERATOR (object);
	switch (property_id) {
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_gee_hash_map_key_iterator_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GeeHashMapKeyIterator * self;
	self = GEE_HASH_MAP_KEY_ITERATOR (object);
	switch (property_id) {
		case GEE_HASH_MAP_KEY_ITERATOR_K_TYPE:
		self->priv->k_type = g_value_get_gtype (value);
		break;
		case GEE_HASH_MAP_KEY_ITERATOR_K_DUP_FUNC:
		self->priv->k_dup_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_KEY_ITERATOR_K_DESTROY_FUNC:
		self->priv->k_destroy_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_KEY_ITERATOR_V_TYPE:
		self->priv->v_type = g_value_get_gtype (value);
		break;
		case GEE_HASH_MAP_KEY_ITERATOR_V_DUP_FUNC:
		self->priv->v_dup_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_KEY_ITERATOR_V_DESTROY_FUNC:
		self->priv->v_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static GeeHashMapMapIterator* gee_hash_map_map_iterator_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map) {
	GeeHashMapMapIterator * self = NULL;
	GeeHashMap* _tmp0_;
	g_return_val_if_fail (map != NULL, NULL);
	_tmp0_ = map;
	self = (GeeHashMapMapIterator*) gee_hash_map_node_iterator_construct (object_type, k_type, (GBoxedCopyFunc) k_dup_func, k_destroy_func, v_type, (GBoxedCopyFunc) v_dup_func, v_destroy_func, _tmp0_);
	self->priv->k_type = k_type;
	self->priv->k_dup_func = k_dup_func;
	self->priv->k_destroy_func = k_destroy_func;
	self->priv->v_type = v_type;
	self->priv->v_dup_func = v_dup_func;
	self->priv->v_destroy_func = v_destroy_func;
	return self;
}


static GeeHashMapMapIterator* gee_hash_map_map_iterator_new (GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map) {
	return gee_hash_map_map_iterator_construct (GEE_HASH_MAP_TYPE_MAP_ITERATOR, k_type, k_dup_func, k_destroy_func, v_type, v_dup_func, v_destroy_func, map);
}


static gpointer gee_hash_map_map_iterator_real_get_key (GeeMapIterator* base) {
	GeeHashMapMapIterator * self;
	gpointer result = NULL;
	gint _tmp0_;
	GeeHashMap* _tmp1_;
	gint _tmp2_;
	GeeHashMapNode* _tmp3_;
	GeeHashMapNode* _tmp4_;
	gconstpointer _tmp5_;
	gpointer _tmp6_;
	self = (GeeHashMapMapIterator*) base;
	_tmp0_ = ((GeeHashMapNodeIterator*) self)->_stamp;
	_tmp1_ = ((GeeHashMapNodeIterator*) self)->_map;
	_tmp2_ = _tmp1_->priv->_stamp;
	g_assert (_tmp0_ == _tmp2_);
	_tmp3_ = ((GeeHashMapNodeIterator*) self)->_node;
	g_assert (_tmp3_ != NULL);
	_tmp4_ = ((GeeHashMapNodeIterator*) self)->_node;
	_tmp5_ = _tmp4_->key;
	_tmp6_ = ((_tmp5_ != NULL) && (self->priv->k_dup_func != NULL)) ? self->priv->k_dup_func ((gpointer) _tmp5_) : ((gpointer) _tmp5_);
	result = _tmp6_;
	return result;
}


static void gee_hash_map_map_iterator_real_unset (GeeMapIterator* base) {
	GeeHashMapMapIterator * self;
	gint _tmp0_;
	GeeHashMap* _tmp1_;
	gint _tmp2_;
	GeeHashMapNode* _tmp3_;
	GeeHashMap* _tmp4_;
	GeeHashMapNode* _tmp5_;
	gconstpointer _tmp6_;
	GeeHashMap* _tmp7_;
	gint _tmp8_;
	self = (GeeHashMapMapIterator*) base;
	_tmp0_ = ((GeeHashMapNodeIterator*) self)->_stamp;
	_tmp1_ = ((GeeHashMapNodeIterator*) self)->_map;
	_tmp2_ = _tmp1_->priv->_stamp;
	g_assert (_tmp0_ == _tmp2_);
	_tmp3_ = ((GeeHashMapNodeIterator*) self)->_node;
	g_assert (_tmp3_ != NULL);
	gee_map_iterator_has_next ((GeeMapIterator*) self);
	_tmp4_ = ((GeeHashMapNodeIterator*) self)->_map;
	_tmp5_ = ((GeeHashMapNodeIterator*) self)->_node;
	_tmp6_ = _tmp5_->key;
	gee_abstract_map_unset ((GeeAbstractMap*) _tmp4_, _tmp6_, NULL);
	((GeeHashMapNodeIterator*) self)->_node = NULL;
	_tmp7_ = ((GeeHashMapNodeIterator*) self)->_map;
	_tmp8_ = _tmp7_->priv->_stamp;
	((GeeHashMapNodeIterator*) self)->_stamp = _tmp8_;
}


static gpointer gee_hash_map_map_iterator_real_get_value (GeeMapIterator* base) {
	GeeHashMapMapIterator * self;
	gpointer result = NULL;
	gint _tmp0_;
	GeeHashMap* _tmp1_;
	gint _tmp2_;
	GeeHashMapNode* _tmp3_;
	GeeHashMapNode* _tmp4_;
	gconstpointer _tmp5_;
	gpointer _tmp6_;
	self = (GeeHashMapMapIterator*) base;
	_tmp0_ = ((GeeHashMapNodeIterator*) self)->_stamp;
	_tmp1_ = ((GeeHashMapNodeIterator*) self)->_map;
	_tmp2_ = _tmp1_->priv->_stamp;
	g_assert (_tmp0_ == _tmp2_);
	_tmp3_ = ((GeeHashMapNodeIterator*) self)->_node;
	g_assert (_tmp3_ != NULL);
	_tmp4_ = ((GeeHashMapNodeIterator*) self)->_node;
	_tmp5_ = _tmp4_->value;
	_tmp6_ = ((_tmp5_ != NULL) && (self->priv->v_dup_func != NULL)) ? self->priv->v_dup_func ((gpointer) _tmp5_) : ((gpointer) _tmp5_);
	result = _tmp6_;
	return result;
}


static void gee_hash_map_map_iterator_real_set_value (GeeMapIterator* base, gconstpointer value) {
	GeeHashMapMapIterator * self;
	gint _tmp0_;
	GeeHashMap* _tmp1_;
	gint _tmp2_;
	GeeHashMapNode* _tmp3_;
	GeeHashMap* _tmp4_;
	GeeHashMapNode* _tmp5_;
	gconstpointer _tmp6_;
	gconstpointer _tmp7_;
	GeeHashMap* _tmp8_;
	gint _tmp9_;
	self = (GeeHashMapMapIterator*) base;
	_tmp0_ = ((GeeHashMapNodeIterator*) self)->_stamp;
	_tmp1_ = ((GeeHashMapNodeIterator*) self)->_map;
	_tmp2_ = _tmp1_->priv->_stamp;
	g_assert (_tmp0_ == _tmp2_);
	_tmp3_ = ((GeeHashMapNodeIterator*) self)->_node;
	g_assert (_tmp3_ != NULL);
	_tmp4_ = ((GeeHashMapNodeIterator*) self)->_map;
	_tmp5_ = ((GeeHashMapNodeIterator*) self)->_node;
	_tmp6_ = _tmp5_->key;
	_tmp7_ = value;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp4_, _tmp6_, _tmp7_);
	_tmp8_ = ((GeeHashMapNodeIterator*) self)->_map;
	_tmp9_ = _tmp8_->priv->_stamp;
	((GeeHashMapNodeIterator*) self)->_stamp = _tmp9_;
}


static void gee_hash_map_map_iterator_class_init (GeeHashMapMapIteratorClass * klass) {
	gee_hash_map_map_iterator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GeeHashMapMapIteratorPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_hash_map_map_iterator_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_hash_map_map_iterator_set_property;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_MAP_ITERATOR_K_TYPE, g_param_spec_gtype ("k-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_MAP_ITERATOR_K_DUP_FUNC, g_param_spec_pointer ("k-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_MAP_ITERATOR_K_DESTROY_FUNC, g_param_spec_pointer ("k-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_MAP_ITERATOR_V_TYPE, g_param_spec_gtype ("v-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_MAP_ITERATOR_V_DUP_FUNC, g_param_spec_pointer ("v-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_MAP_ITERATOR_V_DESTROY_FUNC, g_param_spec_pointer ("v-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}


static void gee_hash_map_map_iterator_gee_map_iterator_interface_init (GeeMapIteratorIface * iface) {
	gee_hash_map_map_iterator_gee_map_iterator_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_key = (gpointer (*)(GeeMapIterator*)) gee_hash_map_map_iterator_real_get_key;
	iface->unset = (void (*)(GeeMapIterator*)) gee_hash_map_map_iterator_real_unset;
	iface->get_value = (gpointer (*)(GeeMapIterator*)) gee_hash_map_map_iterator_real_get_value;
	iface->set_value = (void (*)(GeeMapIterator*, gconstpointer)) gee_hash_map_map_iterator_real_set_value;
	iface->next = (gboolean (*)(GeeMapIterator*)) gee_hash_map_node_iterator_next;
	iface->has_next = (gboolean (*)(GeeMapIterator*)) gee_hash_map_node_iterator_has_next;
	iface->first = (gboolean (*)(GeeMapIterator*)) gee_hash_map_node_iterator_first;
}


static void gee_hash_map_map_iterator_instance_init (GeeHashMapMapIterator * self) {
	self->priv = GEE_HASH_MAP_MAP_ITERATOR_GET_PRIVATE (self);
}


static GType gee_hash_map_map_iterator_get_type (void) {
	static volatile gsize gee_hash_map_map_iterator_type_id__volatile = 0;
	if (g_once_init_enter (&gee_hash_map_map_iterator_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GeeHashMapMapIteratorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_hash_map_map_iterator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeHashMapMapIterator), 0, (GInstanceInitFunc) gee_hash_map_map_iterator_instance_init, NULL };
		static const GInterfaceInfo gee_map_iterator_info = { (GInterfaceInitFunc) gee_hash_map_map_iterator_gee_map_iterator_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType gee_hash_map_map_iterator_type_id;
		gee_hash_map_map_iterator_type_id = g_type_register_static (GEE_HASH_MAP_TYPE_NODE_ITERATOR, "GeeHashMapMapIterator", &g_define_type_info, 0);
		g_type_add_interface_static (gee_hash_map_map_iterator_type_id, GEE_TYPE_MAP_ITERATOR, &gee_map_iterator_info);
		g_once_init_leave (&gee_hash_map_map_iterator_type_id__volatile, gee_hash_map_map_iterator_type_id);
	}
	return gee_hash_map_map_iterator_type_id__volatile;
}


static void _vala_gee_hash_map_map_iterator_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GeeHashMapMapIterator * self;
	self = GEE_HASH_MAP_MAP_ITERATOR (object);
	switch (property_id) {
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_gee_hash_map_map_iterator_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GeeHashMapMapIterator * self;
	self = GEE_HASH_MAP_MAP_ITERATOR (object);
	switch (property_id) {
		case GEE_HASH_MAP_MAP_ITERATOR_K_TYPE:
		self->priv->k_type = g_value_get_gtype (value);
		break;
		case GEE_HASH_MAP_MAP_ITERATOR_K_DUP_FUNC:
		self->priv->k_dup_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_MAP_ITERATOR_K_DESTROY_FUNC:
		self->priv->k_destroy_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_MAP_ITERATOR_V_TYPE:
		self->priv->v_type = g_value_get_gtype (value);
		break;
		case GEE_HASH_MAP_MAP_ITERATOR_V_DUP_FUNC:
		self->priv->v_dup_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_MAP_ITERATOR_V_DESTROY_FUNC:
		self->priv->v_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static GeeHashMapValueIterator* gee_hash_map_value_iterator_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map) {
	GeeHashMapValueIterator * self = NULL;
	GeeHashMap* _tmp0_;
	g_return_val_if_fail (map != NULL, NULL);
	_tmp0_ = map;
	self = (GeeHashMapValueIterator*) gee_hash_map_node_iterator_construct (object_type, k_type, (GBoxedCopyFunc) k_dup_func, k_destroy_func, v_type, (GBoxedCopyFunc) v_dup_func, v_destroy_func, _tmp0_);
	self->priv->k_type = k_type;
	self->priv->k_dup_func = k_dup_func;
	self->priv->k_destroy_func = k_destroy_func;
	self->priv->v_type = v_type;
	self->priv->v_dup_func = v_dup_func;
	self->priv->v_destroy_func = v_destroy_func;
	return self;
}


static GeeHashMapValueIterator* gee_hash_map_value_iterator_new (GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map) {
	return gee_hash_map_value_iterator_construct (GEE_HASH_MAP_TYPE_VALUE_ITERATOR, k_type, k_dup_func, k_destroy_func, v_type, v_dup_func, v_destroy_func, map);
}


static gpointer gee_hash_map_value_iterator_real_get (GeeIterator* base) {
	GeeHashMapValueIterator * self;
	gpointer result = NULL;
	gint _tmp0_;
	GeeHashMap* _tmp1_;
	gint _tmp2_;
	GeeHashMapNode* _tmp3_;
	GeeHashMapNode* _tmp4_;
	gconstpointer _tmp5_;
	gpointer _tmp6_;
	self = (GeeHashMapValueIterator*) base;
	_tmp0_ = ((GeeHashMapNodeIterator*) self)->_stamp;
	_tmp1_ = ((GeeHashMapNodeIterator*) self)->_map;
	_tmp2_ = _tmp1_->priv->_stamp;
	g_assert (_tmp0_ == _tmp2_);
	_tmp3_ = ((GeeHashMapNodeIterator*) self)->_node;
	g_assert (_tmp3_ != NULL);
	_tmp4_ = ((GeeHashMapNodeIterator*) self)->_node;
	_tmp5_ = _tmp4_->value;
	_tmp6_ = ((_tmp5_ != NULL) && (self->priv->v_dup_func != NULL)) ? self->priv->v_dup_func ((gpointer) _tmp5_) : ((gpointer) _tmp5_);
	result = _tmp6_;
	return result;
}


static void gee_hash_map_value_iterator_real_remove (GeeIterator* base) {
	GeeHashMapValueIterator * self;
	self = (GeeHashMapValueIterator*) base;
	g_assert_not_reached ();
}


static void gee_hash_map_value_iterator_class_init (GeeHashMapValueIteratorClass * klass) {
	gee_hash_map_value_iterator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GeeHashMapValueIteratorPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_hash_map_value_iterator_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_hash_map_value_iterator_set_property;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_VALUE_ITERATOR_K_TYPE, g_param_spec_gtype ("k-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_VALUE_ITERATOR_K_DUP_FUNC, g_param_spec_pointer ("k-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_VALUE_ITERATOR_K_DESTROY_FUNC, g_param_spec_pointer ("k-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_VALUE_ITERATOR_V_TYPE, g_param_spec_gtype ("v-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_VALUE_ITERATOR_V_DUP_FUNC, g_param_spec_pointer ("v-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_VALUE_ITERATOR_V_DESTROY_FUNC, g_param_spec_pointer ("v-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}


static void gee_hash_map_value_iterator_gee_iterator_interface_init (GeeIteratorIface * iface) {
	gee_hash_map_value_iterator_gee_iterator_parent_iface = g_type_interface_peek_parent (iface);
	iface->get = (gpointer (*)(GeeIterator*)) gee_hash_map_value_iterator_real_get;
	iface->remove = (void (*)(GeeIterator*)) gee_hash_map_value_iterator_real_remove;
	iface->next = (gboolean (*)(GeeIterator*)) gee_hash_map_node_iterator_next;
	iface->has_next = (gboolean (*)(GeeIterator*)) gee_hash_map_node_iterator_has_next;
	iface->first = (gboolean (*)(GeeIterator*)) gee_hash_map_node_iterator_first;
}


static void gee_hash_map_value_iterator_instance_init (GeeHashMapValueIterator * self) {
	self->priv = GEE_HASH_MAP_VALUE_ITERATOR_GET_PRIVATE (self);
}


static GType gee_hash_map_value_iterator_get_type (void) {
	static volatile gsize gee_hash_map_value_iterator_type_id__volatile = 0;
	if (g_once_init_enter (&gee_hash_map_value_iterator_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GeeHashMapValueIteratorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_hash_map_value_iterator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeHashMapValueIterator), 0, (GInstanceInitFunc) gee_hash_map_value_iterator_instance_init, NULL };
		static const GInterfaceInfo gee_iterator_info = { (GInterfaceInitFunc) gee_hash_map_value_iterator_gee_iterator_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType gee_hash_map_value_iterator_type_id;
		gee_hash_map_value_iterator_type_id = g_type_register_static (GEE_HASH_MAP_TYPE_NODE_ITERATOR, "GeeHashMapValueIterator", &g_define_type_info, 0);
		g_type_add_interface_static (gee_hash_map_value_iterator_type_id, GEE_TYPE_ITERATOR, &gee_iterator_info);
		g_once_init_leave (&gee_hash_map_value_iterator_type_id__volatile, gee_hash_map_value_iterator_type_id);
	}
	return gee_hash_map_value_iterator_type_id__volatile;
}


static void _vala_gee_hash_map_value_iterator_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GeeHashMapValueIterator * self;
	self = GEE_HASH_MAP_VALUE_ITERATOR (object);
	switch (property_id) {
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_gee_hash_map_value_iterator_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GeeHashMapValueIterator * self;
	self = GEE_HASH_MAP_VALUE_ITERATOR (object);
	switch (property_id) {
		case GEE_HASH_MAP_VALUE_ITERATOR_K_TYPE:
		self->priv->k_type = g_value_get_gtype (value);
		break;
		case GEE_HASH_MAP_VALUE_ITERATOR_K_DUP_FUNC:
		self->priv->k_dup_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_VALUE_ITERATOR_K_DESTROY_FUNC:
		self->priv->k_destroy_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_VALUE_ITERATOR_V_TYPE:
		self->priv->v_type = g_value_get_gtype (value);
		break;
		case GEE_HASH_MAP_VALUE_ITERATOR_V_DUP_FUNC:
		self->priv->v_dup_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_VALUE_ITERATOR_V_DESTROY_FUNC:
		self->priv->v_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static GeeHashMapEntryIterator* gee_hash_map_entry_iterator_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map) {
	GeeHashMapEntryIterator * self = NULL;
	GeeHashMap* _tmp0_;
	g_return_val_if_fail (map != NULL, NULL);
	_tmp0_ = map;
	self = (GeeHashMapEntryIterator*) gee_hash_map_node_iterator_construct (object_type, k_type, (GBoxedCopyFunc) k_dup_func, k_destroy_func, v_type, (GBoxedCopyFunc) v_dup_func, v_destroy_func, _tmp0_);
	self->priv->k_type = k_type;
	self->priv->k_dup_func = k_dup_func;
	self->priv->k_destroy_func = k_destroy_func;
	self->priv->v_type = v_type;
	self->priv->v_dup_func = v_dup_func;
	self->priv->v_destroy_func = v_destroy_func;
	return self;
}


static GeeHashMapEntryIterator* gee_hash_map_entry_iterator_new (GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, GeeHashMap* map) {
	return gee_hash_map_entry_iterator_construct (GEE_HASH_MAP_TYPE_ENTRY_ITERATOR, k_type, k_dup_func, k_destroy_func, v_type, v_dup_func, v_destroy_func, map);
}


static GeeMapEntry* gee_hash_map_entry_iterator_real_get (GeeIterator* base) {
	GeeHashMapEntryIterator * self;
	GeeMapEntry* result = NULL;
	gint _tmp0_;
	GeeHashMap* _tmp1_;
	gint _tmp2_;
	GeeHashMapNode* _tmp3_;
	GeeHashMapNode* _tmp4_;
	GeeMapEntry* _tmp5_ = NULL;
	self = (GeeHashMapEntryIterator*) base;
	_tmp0_ = ((GeeHashMapNodeIterator*) self)->_stamp;
	_tmp1_ = ((GeeHashMapNodeIterator*) self)->_map;
	_tmp2_ = _tmp1_->priv->_stamp;
	g_assert (_tmp0_ == _tmp2_);
	_tmp3_ = ((GeeHashMapNodeIterator*) self)->_node;
	g_assert (_tmp3_ != NULL);
	_tmp4_ = ((GeeHashMapNodeIterator*) self)->_node;
	_tmp5_ = gee_hash_map_entry_entry_for (self->priv->k_type, (GBoxedCopyFunc) self->priv->k_dup_func, self->priv->k_destroy_func, self->priv->v_type, (GBoxedCopyFunc) self->priv->v_dup_func, self->priv->v_destroy_func, _tmp4_);
	result = _tmp5_;
	return result;
}


static void gee_hash_map_entry_iterator_real_remove (GeeIterator* base) {
	GeeHashMapEntryIterator * self;
	self = (GeeHashMapEntryIterator*) base;
	g_assert_not_reached ();
}


static void gee_hash_map_entry_iterator_class_init (GeeHashMapEntryIteratorClass * klass) {
	gee_hash_map_entry_iterator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GeeHashMapEntryIteratorPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_hash_map_entry_iterator_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_hash_map_entry_iterator_set_property;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_ENTRY_ITERATOR_K_TYPE, g_param_spec_gtype ("k-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_ENTRY_ITERATOR_K_DUP_FUNC, g_param_spec_pointer ("k-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_ENTRY_ITERATOR_K_DESTROY_FUNC, g_param_spec_pointer ("k-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_ENTRY_ITERATOR_V_TYPE, g_param_spec_gtype ("v-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_ENTRY_ITERATOR_V_DUP_FUNC, g_param_spec_pointer ("v-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_ENTRY_ITERATOR_V_DESTROY_FUNC, g_param_spec_pointer ("v-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}


static void gee_hash_map_entry_iterator_gee_iterator_interface_init (GeeIteratorIface * iface) {
	gee_hash_map_entry_iterator_gee_iterator_parent_iface = g_type_interface_peek_parent (iface);
	iface->get = (gpointer (*)(GeeIterator*)) gee_hash_map_entry_iterator_real_get;
	iface->remove = (void (*)(GeeIterator*)) gee_hash_map_entry_iterator_real_remove;
	iface->next = (gboolean (*)(GeeIterator*)) gee_hash_map_node_iterator_next;
	iface->has_next = (gboolean (*)(GeeIterator*)) gee_hash_map_node_iterator_has_next;
	iface->first = (gboolean (*)(GeeIterator*)) gee_hash_map_node_iterator_first;
}


static void gee_hash_map_entry_iterator_instance_init (GeeHashMapEntryIterator * self) {
	self->priv = GEE_HASH_MAP_ENTRY_ITERATOR_GET_PRIVATE (self);
}


static GType gee_hash_map_entry_iterator_get_type (void) {
	static volatile gsize gee_hash_map_entry_iterator_type_id__volatile = 0;
	if (g_once_init_enter (&gee_hash_map_entry_iterator_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GeeHashMapEntryIteratorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_hash_map_entry_iterator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeHashMapEntryIterator), 0, (GInstanceInitFunc) gee_hash_map_entry_iterator_instance_init, NULL };
		static const GInterfaceInfo gee_iterator_info = { (GInterfaceInitFunc) gee_hash_map_entry_iterator_gee_iterator_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType gee_hash_map_entry_iterator_type_id;
		gee_hash_map_entry_iterator_type_id = g_type_register_static (GEE_HASH_MAP_TYPE_NODE_ITERATOR, "GeeHashMapEntryIterator", &g_define_type_info, 0);
		g_type_add_interface_static (gee_hash_map_entry_iterator_type_id, GEE_TYPE_ITERATOR, &gee_iterator_info);
		g_once_init_leave (&gee_hash_map_entry_iterator_type_id__volatile, gee_hash_map_entry_iterator_type_id);
	}
	return gee_hash_map_entry_iterator_type_id__volatile;
}


static void _vala_gee_hash_map_entry_iterator_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GeeHashMapEntryIterator * self;
	self = GEE_HASH_MAP_ENTRY_ITERATOR (object);
	switch (property_id) {
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_gee_hash_map_entry_iterator_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GeeHashMapEntryIterator * self;
	self = GEE_HASH_MAP_ENTRY_ITERATOR (object);
	switch (property_id) {
		case GEE_HASH_MAP_ENTRY_ITERATOR_K_TYPE:
		self->priv->k_type = g_value_get_gtype (value);
		break;
		case GEE_HASH_MAP_ENTRY_ITERATOR_K_DUP_FUNC:
		self->priv->k_dup_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_ENTRY_ITERATOR_K_DESTROY_FUNC:
		self->priv->k_destroy_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_ENTRY_ITERATOR_V_TYPE:
		self->priv->v_type = g_value_get_gtype (value);
		break;
		case GEE_HASH_MAP_ENTRY_ITERATOR_V_DUP_FUNC:
		self->priv->v_dup_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_ENTRY_ITERATOR_V_DESTROY_FUNC:
		self->priv->v_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void gee_hash_map_class_init (GeeHashMapClass * klass) {
	gee_hash_map_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GeeHashMapPrivate));
	GEE_ABSTRACT_MAP_CLASS (klass)->has_key = gee_hash_map_real_has_key;
	GEE_ABSTRACT_MAP_CLASS (klass)->has = gee_hash_map_real_has;
	GEE_ABSTRACT_MAP_CLASS (klass)->get = gee_hash_map_real_get;
	GEE_ABSTRACT_MAP_CLASS (klass)->set = gee_hash_map_real_set;
	GEE_ABSTRACT_MAP_CLASS (klass)->unset = gee_hash_map_real_unset;
	GEE_ABSTRACT_MAP_CLASS (klass)->clear = gee_hash_map_real_clear;
	GEE_ABSTRACT_MAP_CLASS (klass)->map_iterator = gee_hash_map_real_map_iterator;
	GEE_ABSTRACT_MAP_CLASS (klass)->get_size = gee_hash_map_real_get_size;
	GEE_ABSTRACT_MAP_CLASS (klass)->get_keys = gee_hash_map_real_get_keys;
	GEE_ABSTRACT_MAP_CLASS (klass)->get_values = gee_hash_map_real_get_values;
	GEE_ABSTRACT_MAP_CLASS (klass)->get_entries = gee_hash_map_real_get_entries;
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_hash_map_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_hash_map_set_property;
	G_OBJECT_CLASS (klass)->finalize = gee_hash_map_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_K_TYPE, g_param_spec_gtype ("k-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_K_DUP_FUNC, g_param_spec_pointer ("k-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_K_DESTROY_FUNC, g_param_spec_pointer ("k-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_V_TYPE, g_param_spec_gtype ("v-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_V_DUP_FUNC, g_param_spec_pointer ("v-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_V_DESTROY_FUNC, g_param_spec_pointer ("v-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	/**
	 * {@inheritDoc}
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_SIZE, g_param_spec_int ("size", "size", "size", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	 * {@inheritDoc}
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_KEYS, g_param_spec_object ("keys", "keys", "keys", GEE_TYPE_SET, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	 * {@inheritDoc}
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_VALUES, g_param_spec_object ("values", "values", "values", GEE_TYPE_COLLECTION, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	 * {@inheritDoc}
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_ENTRIES, g_param_spec_object ("entries", "entries", "entries", GEE_TYPE_SET, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	 * The keys' hash function.
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_KEY_HASH_FUNC, g_param_spec_pointer ("key-hash-func", "key-hash-func", "key-hash-func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	 * The keys' equality testing function.
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_KEY_EQUAL_FUNC, g_param_spec_pointer ("key-equal-func", "key-equal-func", "key-equal-func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	 * The values' equality testing function.
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_HASH_MAP_VALUE_EQUAL_FUNC, g_param_spec_pointer ("value-equal-func", "value-equal-func", "value-equal-func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void gee_hash_map_instance_init (GeeHashMap * self) {
	self->priv = GEE_HASH_MAP_GET_PRIVATE (self);
	self->priv->_stamp = 0;
}


static void gee_hash_map_finalize (GObject* obj) {
	GeeHashMap * self;
	self = GEE_HASH_MAP (obj);
	gee_abstract_map_clear ((GeeAbstractMap*) self);
	self->priv->_nodes = (_vala_array_free (self->priv->_nodes, self->priv->_nodes_length1, (GDestroyNotify) gee_hash_map_node_free), NULL);
	G_OBJECT_CLASS (gee_hash_map_parent_class)->finalize (obj);
}


/**
 * Hash table implementation of the {@link Map} interface.
 *
 * This implementation is better fit for highly heterogenous key values.
 * In case of high key hashes redundancy or higher amount of data prefer using
 * tree implementation like {@link TreeMap}.
 *
 * @see TreeMap
 */
GType gee_hash_map_get_type (void) {
	static volatile gsize gee_hash_map_type_id__volatile = 0;
	if (g_once_init_enter (&gee_hash_map_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GeeHashMapClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_hash_map_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeHashMap), 0, (GInstanceInitFunc) gee_hash_map_instance_init, NULL };
		GType gee_hash_map_type_id;
		gee_hash_map_type_id = g_type_register_static (GEE_TYPE_ABSTRACT_MAP, "GeeHashMap", &g_define_type_info, 0);
		g_once_init_leave (&gee_hash_map_type_id__volatile, gee_hash_map_type_id);
	}
	return gee_hash_map_type_id__volatile;
}


static void _vala_gee_hash_map_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GeeHashMap * self;
	self = GEE_HASH_MAP (object);
	switch (property_id) {
		case GEE_HASH_MAP_SIZE:
		g_value_set_int (value, gee_abstract_map_get_size ((GeeAbstractMap*) self));
		break;
		case GEE_HASH_MAP_KEYS:
		g_value_take_object (value, gee_abstract_map_get_keys ((GeeAbstractMap*) self));
		break;
		case GEE_HASH_MAP_VALUES:
		g_value_take_object (value, gee_abstract_map_get_values ((GeeAbstractMap*) self));
		break;
		case GEE_HASH_MAP_ENTRIES:
		g_value_take_object (value, gee_abstract_map_get_entries ((GeeAbstractMap*) self));
		break;
		case GEE_HASH_MAP_KEY_HASH_FUNC:
		g_value_set_pointer (value, gee_hash_map_get_key_hash_func (self));
		break;
		case GEE_HASH_MAP_KEY_EQUAL_FUNC:
		g_value_set_pointer (value, gee_hash_map_get_key_equal_func (self));
		break;
		case GEE_HASH_MAP_VALUE_EQUAL_FUNC:
		g_value_set_pointer (value, gee_hash_map_get_value_equal_func (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_gee_hash_map_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GeeHashMap * self;
	self = GEE_HASH_MAP (object);
	switch (property_id) {
		case GEE_HASH_MAP_KEY_HASH_FUNC:
		gee_hash_map_set_key_hash_func (self, g_value_get_pointer (value));
		break;
		case GEE_HASH_MAP_KEY_EQUAL_FUNC:
		gee_hash_map_set_key_equal_func (self, g_value_get_pointer (value));
		break;
		case GEE_HASH_MAP_VALUE_EQUAL_FUNC:
		gee_hash_map_set_value_equal_func (self, g_value_get_pointer (value));
		break;
		case GEE_HASH_MAP_K_TYPE:
		self->priv->k_type = g_value_get_gtype (value);
		break;
		case GEE_HASH_MAP_K_DUP_FUNC:
		self->priv->k_dup_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_K_DESTROY_FUNC:
		self->priv->k_destroy_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_V_TYPE:
		self->priv->v_type = g_value_get_gtype (value);
		break;
		case GEE_HASH_MAP_V_DUP_FUNC:
		self->priv->v_dup_func = g_value_get_pointer (value);
		break;
		case GEE_HASH_MAP_V_DESTROY_FUNC:
		self->priv->v_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



